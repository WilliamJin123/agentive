"""Code merging for HFS - combines artifacts from all triads.

The CodeMerger takes artifacts generated by triads during execution phase
and combines them into a unified codebase. It handles:
- Import/export boundary resolution
- Style combination and deduplication
- File organization and structure

Key concepts:
- Artifacts: Dict mapping triad_id -> Dict mapping section -> code
- MergedArtifact: Unified codebase with resolved dependencies
- Import resolution: Ensures cross-triad references work correctly
"""

from dataclasses import dataclass, field
from typing import Dict, List, Any, Optional, Set
import re
from enum import Enum


class ArtifactType(Enum):
    """Types of artifacts that can be merged."""
    COMPONENT = "component"
    STYLE = "style"
    UTILITY = "utility"
    TYPE = "type"
    CONFIG = "config"
    TEST = "test"


@dataclass
class FileArtifact:
    """A single file artifact ready for merging.

    Attributes:
        path: Relative path for this file in the output.
        content: The file content.
        artifact_type: Type of artifact (component, style, etc.).
        source_triad: ID of the triad that generated this.
        source_section: Section name this was generated for.
        imports: List of import statements detected.
        exports: List of exported identifiers.
    """
    path: str
    content: str
    artifact_type: ArtifactType
    source_triad: str
    source_section: str
    imports: List[str] = field(default_factory=list)
    exports: List[str] = field(default_factory=list)


@dataclass
class MergedArtifact:
    """The result of merging all triad artifacts.

    Attributes:
        files: Dict mapping file paths to content.
        entry_point: Path to the main entry file.
        component_index: Index of components by name.
        style_bundle: Combined styles if applicable.
        metadata: Additional merge metadata.
        warnings: Any warnings generated during merge.
    """
    files: Dict[str, str] = field(default_factory=dict)
    entry_point: Optional[str] = None
    component_index: Dict[str, str] = field(default_factory=dict)
    style_bundle: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)
    warnings: List[str] = field(default_factory=list)

    @property
    def file_count(self) -> int:
        """Return the number of files in the merged artifact."""
        return len(self.files)

    @property
    def total_size(self) -> int:
        """Return total size in characters across all files."""
        return sum(len(content) for content in self.files.values())

    def get_file(self, path: str) -> Optional[str]:
        """Get content of a specific file."""
        return self.files.get(path)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "files": self.files,
            "entry_point": self.entry_point,
            "component_index": self.component_index,
            "style_bundle": self.style_bundle,
            "metadata": self.metadata,
            "warnings": self.warnings,
            "file_count": self.file_count,
            "total_size": self.total_size,
        }


class CodeMerger:
    """Merges artifacts from all triads into a unified codebase.

    The merger handles:
    1. Collecting artifacts from all triads
    2. Organizing files by type and section
    3. Resolving import/export boundaries
    4. Combining styles
    5. Generating index files

    Example usage:
        merger = CodeMerger()
        artifacts = {
            "visual_triad": {"hero_section": "const Hero = () => {...}"},
            "layout_triad": {"grid_system": "export const Grid = {...}"},
        }
        merged = merger.merge(artifacts, frozen_spec)
        print(merged.files)
    """

    def __init__(self, output_format: str = "react") -> None:
        """Initialize the CodeMerger.

        Args:
            output_format: Target format for output (react, vue, html).
        """
        self.output_format = output_format
        self._import_pattern = re.compile(
            r'^import\s+(?:(?:\{[^}]+\})|(?:\*\s+as\s+\w+)|(?:\w+))?\s*'
            r'(?:,\s*(?:\{[^}]+\}|\w+))?\s*from\s+[\'"]([^\'"]+)[\'"]',
            re.MULTILINE
        )
        self._export_pattern = re.compile(
            r'^export\s+(?:default\s+)?(?:const|function|class|let|var)?\s*(\w+)',
            re.MULTILINE
        )

    def merge(
        self,
        artifacts: Dict[str, Dict[str, str]],
        spec: Any
    ) -> MergedArtifact:
        """Merge artifacts from all triads into unified codebase.

        Args:
            artifacts: Dict mapping triad_id -> Dict mapping section -> code.
            spec: The frozen Spec with section ownership information.

        Returns:
            MergedArtifact containing the unified codebase.
        """
        merged = MergedArtifact()

        if not artifacts:
            merged.warnings.append("No artifacts provided for merging")
            return merged

        # Phase 1: Collect and classify all artifacts
        file_artifacts = self._collect_artifacts(artifacts, spec)

        # Phase 2: Resolve imports/exports
        resolved = self._resolve_imports(file_artifacts, merged)

        # Phase 3: Combine styles
        self._combine_styles(resolved, merged)

        # Phase 4: Generate file structure
        self._generate_file_structure(resolved, merged)

        # Phase 5: Create index/entry point
        self._create_entry_point(merged)

        # Add metadata
        merged.metadata = {
            "triad_count": len(artifacts),
            "section_count": sum(len(sections) for sections in artifacts.values()),
            "output_format": self.output_format,
        }

        return merged

    def _collect_artifacts(
        self,
        artifacts: Dict[str, Dict[str, str]],
        spec: Any
    ) -> List[FileArtifact]:
        """Collect and classify artifacts from all triads.

        Args:
            artifacts: Raw artifacts from triads.
            spec: The frozen spec.

        Returns:
            List of FileArtifact objects.
        """
        file_artifacts: List[FileArtifact] = []

        for triad_id, sections in artifacts.items():
            for section_name, code in sections.items():
                if not code or not isinstance(code, str):
                    continue

                # Determine artifact type from content
                artifact_type = self._classify_artifact(code, section_name)

                # Generate path based on type and section
                path = self._generate_path(section_name, artifact_type)

                # Extract imports and exports
                imports = self._extract_imports(code)
                exports = self._extract_exports(code)

                file_artifacts.append(FileArtifact(
                    path=path,
                    content=code,
                    artifact_type=artifact_type,
                    source_triad=triad_id,
                    source_section=section_name,
                    imports=imports,
                    exports=exports,
                ))

        return file_artifacts

    def _classify_artifact(self, code: str, section_name: str) -> ArtifactType:
        """Classify artifact type based on content and section name.

        Args:
            code: The code content.
            section_name: Name of the section.

        Returns:
            The classified ArtifactType.
        """
        code_lower = code.lower()
        section_lower = section_name.lower()

        # Check for style artifacts
        if any(indicator in code_lower for indicator in [
            '.css', '@tailwind', '@apply', 'styled.', 'css`', ':root {'
        ]) or 'style' in section_lower:
            return ArtifactType.STYLE

        # Check for type definitions
        if any(indicator in code_lower for indicator in [
            'interface ', 'type ', '.d.ts'
        ]) or 'type' in section_lower:
            return ArtifactType.TYPE

        # Check for utility/helper functions
        if any(indicator in section_lower for indicator in [
            'util', 'helper', 'hook', 'lib'
        ]):
            return ArtifactType.UTILITY

        # Check for config
        if any(indicator in section_lower for indicator in [
            'config', 'setting', 'constant'
        ]):
            return ArtifactType.CONFIG

        # Check for tests
        if any(indicator in code_lower for indicator in [
            'describe(', 'test(', 'it(', '@test', 'spec.'
        ]) or 'test' in section_lower:
            return ArtifactType.TEST

        # Default to component
        return ArtifactType.COMPONENT

    def _generate_path(self, section_name: str, artifact_type: ArtifactType) -> str:
        """Generate file path based on section and type.

        Args:
            section_name: Name of the section.
            artifact_type: Type of the artifact.

        Returns:
            Relative file path.
        """
        # Convert section name to file-friendly format
        file_name = self._to_file_name(section_name)

        # Organize by artifact type
        type_dirs = {
            ArtifactType.COMPONENT: "components",
            ArtifactType.STYLE: "styles",
            ArtifactType.UTILITY: "utils",
            ArtifactType.TYPE: "types",
            ArtifactType.CONFIG: "config",
            ArtifactType.TEST: "__tests__",
        }

        directory = type_dirs.get(artifact_type, "components")

        # Determine extension
        if artifact_type == ArtifactType.STYLE:
            ext = ".css"
        elif artifact_type == ArtifactType.TYPE:
            ext = ".ts"
        elif artifact_type == ArtifactType.TEST:
            ext = ".test.tsx"
        else:
            ext = ".tsx" if self.output_format == "react" else ".vue"

        return f"{directory}/{file_name}{ext}"

    def _to_file_name(self, section_name: str) -> str:
        """Convert section name to valid file name.

        Args:
            section_name: The section name.

        Returns:
            File-friendly name in PascalCase.
        """
        # Remove special characters and split on common delimiters
        clean = re.sub(r'[^a-zA-Z0-9_\s-]', '', section_name)
        parts = re.split(r'[-_\s]+', clean)

        # Convert to PascalCase
        return ''.join(part.capitalize() for part in parts if part)

    def _extract_imports(self, code: str) -> List[str]:
        """Extract import statements from code.

        Args:
            code: The code content.

        Returns:
            List of import source paths.
        """
        return self._import_pattern.findall(code)

    def _extract_exports(self, code: str) -> List[str]:
        """Extract exported identifiers from code.

        Args:
            code: The code content.

        Returns:
            List of exported identifier names.
        """
        return self._export_pattern.findall(code)

    def _resolve_imports(
        self,
        file_artifacts: List[FileArtifact],
        merged: MergedArtifact
    ) -> List[FileArtifact]:
        """Resolve import/export boundaries between artifacts.

        Updates import paths to match the merged file structure.
        Detects missing dependencies and circular imports.

        Args:
            file_artifacts: List of file artifacts to process.
            merged: MergedArtifact to add warnings to.

        Returns:
            List of FileArtifact with resolved imports.
        """
        # Build export map: export_name -> file_path
        export_map: Dict[str, str] = {}
        for artifact in file_artifacts:
            for export_name in artifact.exports:
                if export_name in export_map:
                    merged.warnings.append(
                        f"Duplicate export '{export_name}' in {artifact.path} "
                        f"(also in {export_map[export_name]})"
                    )
                export_map[export_name] = artifact.path

        # Build component index
        for artifact in file_artifacts:
            if artifact.artifact_type == ArtifactType.COMPONENT:
                for export_name in artifact.exports:
                    merged.component_index[export_name] = artifact.path

        # Check for missing dependencies
        all_exports: Set[str] = set(export_map.keys())
        for artifact in file_artifacts:
            for imp in artifact.imports:
                # Skip external imports (node_modules)
                if not imp.startswith('.') and not imp.startswith('@/'):
                    continue

                # For internal imports, check if referenced exports exist
                # This is a simplified check - in production would parse the import
                # to find specific named imports and verify they exist

        # In a full implementation, we would rewrite import paths here
        # For now, return artifacts as-is with warnings added

        return file_artifacts

    def _combine_styles(
        self,
        file_artifacts: List[FileArtifact],
        merged: MergedArtifact
    ) -> None:
        """Combine style artifacts into a style bundle.

        Args:
            file_artifacts: All file artifacts.
            merged: MergedArtifact to update.
        """
        style_contents: List[str] = []

        for artifact in file_artifacts:
            if artifact.artifact_type == ArtifactType.STYLE:
                # Add source comment
                style_contents.append(
                    f"/* Source: {artifact.source_triad}/{artifact.source_section} */\n"
                    f"{artifact.content}\n"
                )

        if style_contents:
            merged.style_bundle = "\n".join(style_contents)
            merged.files["styles/bundle.css"] = merged.style_bundle

    def _generate_file_structure(
        self,
        file_artifacts: List[FileArtifact],
        merged: MergedArtifact
    ) -> None:
        """Generate the final file structure.

        Args:
            file_artifacts: Processed file artifacts.
            merged: MergedArtifact to populate.
        """
        for artifact in file_artifacts:
            # Skip styles that were bundled
            if artifact.artifact_type == ArtifactType.STYLE:
                continue

            # Add header comment with source info
            header = (
                f"/**\n"
                f" * Generated by HFS\n"
                f" * Source: {artifact.source_triad}/{artifact.source_section}\n"
                f" */\n\n"
            )

            merged.files[artifact.path] = header + artifact.content

    def _create_entry_point(self, merged: MergedArtifact) -> None:
        """Create the main entry point file.

        Args:
            merged: MergedArtifact to update.
        """
        if not merged.component_index:
            merged.warnings.append("No components found to create entry point")
            return

        # Generate index file that exports all components
        exports = []
        for component_name, path in sorted(merged.component_index.items()):
            # Convert path to import path (remove extension)
            import_path = './' + path.rsplit('.', 1)[0]
            exports.append(f"export {{ {component_name} }} from '{import_path}';")

        entry_content = (
            "/**\n"
            " * HFS Generated Entry Point\n"
            " * Auto-generated component exports\n"
            " */\n\n"
            + "\n".join(exports)
        )

        merged.files["index.ts"] = entry_content
        merged.entry_point = "index.ts"
