---
phase: 09-state-query-layer
plan: 02
type: execute
wave: 2
depends_on: ["09-01"]
files_modified:
  - hfs/state/query.py
  - hfs/state/__init__.py
autonomous: true

must_haves:
  truths:
    - "QueryInterface returns agent tree structure showing triads and agents"
    - "QueryInterface returns negotiation state with claims, contests, owners"
    - "QueryInterface returns token usage breakdown by agent, phase, and total"
    - "QueryInterface returns trace timeline with phase durations"
    - "All query responses are JSON-serializable Pydantic models"
    - "Widgets can subscribe to state changes by category"
    - "Widgets can request changes since a given version"
  artifacts:
    - path: "hfs/state/query.py"
      provides: "QueryInterface class with typed query methods"
      exports: ["QueryInterface", "StateChange", "ChangeCategory"]
    - path: "hfs/state/__init__.py"
      provides: "Updated exports including QueryInterface"
      contains: "QueryInterface"
  key_links:
    - from: "hfs/state/query.py"
      to: "hfs/state/manager.py"
      via: "QueryInterface wraps StateManager"
      pattern: "StateManager"
    - from: "hfs/state/query.py"
      to: "hfs/state/models.py"
      via: "returns Pydantic models"
      pattern: "AgentTree|NegotiationSnapshot|TokenUsageSummary|TraceTimeline"
---

<objective>
Create QueryInterface class that wraps StateManager and provides clean typed query methods.

Purpose: Provide the API that Textual widgets (Phase 10+) will consume. Supports both polling via query methods and subscriptions for real-time updates. Enables efficient incremental updates via version tracking and delta queries.

Output:
- hfs/state/query.py with QueryInterface, StateChange, ChangeCategory
- Updated hfs/state/__init__.py with QueryInterface export
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-state-query-layer/09-CONTEXT.md
@.planning/phases/09-state-query-layer/09-RESEARCH.md

# Plan 01 outputs (will exist after 09-01 executes)
@hfs/state/models.py
@hfs/state/manager.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create QueryInterface with typed query methods</name>
  <files>hfs/state/query.py</files>
  <action>
Create hfs/state/query.py with QueryInterface class per CONTEXT.md and RESEARCH.md:

```python
"""
QueryInterface for clean state queries.

Wraps StateManager and provides typed query methods returning Pydantic models.
Supports both composite queries (get_snapshot) and focused queries (get_agent_tree).
All responses are JSON-serializable via model_dump(mode='json').
"""

from enum import Enum
from typing import Optional, Callable, Awaitable
from datetime import datetime

from pydantic import BaseModel, Field

from hfs.state.manager import StateManager
from hfs.state.models import (
    AgentTree,
    AgentNode,
    TriadInfo,
    NegotiationSnapshot,
    SectionNegotiationState,
    TokenUsageSummary,
    AgentTokenUsage,
    PhaseTokenUsage,
    TraceTimeline,
    PhaseTimeline,
    RunSnapshot,
)


class ChangeCategory(str, Enum):
    """Categories of state changes for subscription filtering."""
    AGENT_TREE = "agent_tree"
    NEGOTIATION = "negotiation"
    USAGE = "usage"
    TIMELINE = "timeline"
    ALL = "all"


class StateChange(BaseModel):
    """Notification of state change."""
    version: int
    category: ChangeCategory
    timestamp: datetime = Field(default_factory=datetime.utcnow)


class QueryInterface:
    """Clean API for querying HFS state.

    Wraps StateManager and provides typed query methods. All methods return
    Pydantic models that serialize to JSON via model_dump(mode='json').

    Supports:
    - Composite queries: get_snapshot() for full state
    - Focused queries: get_agent_tree(), get_negotiation_state(), etc.
    - Parameterized queries: get_agent(agent_id), get_usage_by_phase(phase_name)
    - Delta queries: get_changes_since(version) for efficient incremental updates

    Example:
        >>> query = QueryInterface(state_manager)
        >>> tree = query.get_agent_tree()
        >>> print(tree.model_dump_json())
    """

    def __init__(self, state_manager: StateManager) -> None:
        """Initialize with StateManager reference."""
        self._state = state_manager

    @property
    def version(self) -> int:
        """Current state version for cache invalidation.

        Textual widgets can compare versions to skip re-render if unchanged.
        """
        return self._state.version

    # =========================================================================
    # Composite Queries
    # =========================================================================

    def get_snapshot(self) -> RunSnapshot:
        """Get complete state snapshot.

        Returns full snapshot containing agent tree, negotiation state,
        token usage, and trace timeline. Use for initial load or full refresh.

        Returns:
            RunSnapshot with all state components
        """
        return self._state.build_snapshot()

    # =========================================================================
    # Agent Tree Queries (ABS-03)
    # =========================================================================

    def get_agent_tree(self) -> AgentTree:
        """Get agent tree structure.

        Returns hierarchical view of triads and their agents. Use agent_index
        computed field for flat lookups by agent_id.

        Returns:
            AgentTree with triads list and agent_index computed field
        """
        return self._state.build_agent_tree()

    def get_agent(self, agent_id: str) -> Optional[AgentNode]:
        """Get single agent by ID.

        Args:
            agent_id: The agent's unique identifier

        Returns:
            AgentNode if found, None otherwise
        """
        tree = self._state.build_agent_tree()
        return tree.agent_index.get(agent_id)

    def get_triad(self, triad_id: str) -> Optional[TriadInfo]:
        """Get single triad by ID.

        Args:
            triad_id: The triad's unique identifier

        Returns:
            TriadInfo if found, None otherwise
        """
        return self._state._triads.get(triad_id)

    # =========================================================================
    # Negotiation Queries (ABS-04)
    # =========================================================================

    def get_negotiation_state(self) -> NegotiationSnapshot:
        """Get negotiation state.

        Returns section-centric view with claims, contests, and owners.

        Returns:
            NegotiationSnapshot with sections, temperature, round
        """
        return self._state.build_negotiation_snapshot()

    def get_section(self, section_name: str) -> Optional[SectionNegotiationState]:
        """Get single section's negotiation state.

        Args:
            section_name: The section name

        Returns:
            SectionNegotiationState if found, None otherwise
        """
        return self._state._sections.get(section_name)

    # =========================================================================
    # Token Usage Queries (ABS-05)
    # =========================================================================

    def get_token_usage(self) -> TokenUsageSummary:
        """Get complete token usage breakdown.

        Returns usage by phase and by agent with computed totals.

        Returns:
            TokenUsageSummary with by_phase, by_agent, total_tokens
        """
        return self._state.build_token_usage()

    def get_usage_by_phase(self, phase_name: str) -> Optional[PhaseTokenUsage]:
        """Get token usage for specific phase.

        Args:
            phase_name: The phase name

        Returns:
            PhaseTokenUsage if found, None otherwise
        """
        return self._state._phase_usage.get(phase_name)

    def get_usage_by_agent(self, agent_id: str) -> Optional[AgentTokenUsage]:
        """Get token usage for specific agent.

        Args:
            agent_id: The agent's unique identifier

        Returns:
            AgentTokenUsage if found, None otherwise
        """
        return self._state._agent_usage.get(agent_id)

    # =========================================================================
    # Trace Timeline Queries (ABS-06)
    # =========================================================================

    def get_trace_timeline(self) -> TraceTimeline:
        """Get trace timeline with phase durations.

        Returns timeline of all phases with start/end times and computed durations.

        Returns:
            TraceTimeline with phases list and total_duration_ms
        """
        return self._state.build_trace_timeline()

    def get_phase_timeline(self, phase_name: str) -> Optional[PhaseTimeline]:
        """Get timeline for specific phase.

        Args:
            phase_name: The phase name

        Returns:
            PhaseTimeline if found, None otherwise
        """
        return self._state._phases.get(phase_name)
```

All methods return copies of state (copy-on-read pattern per RESEARCH.md).
All return types are Pydantic models satisfying ABS-08 (JSON-serializable).
  </action>
  <verify>
python -c "from hfs.state.query import QueryInterface, StateChange, ChangeCategory; print('QueryInterface imported OK')"
python -c "
import asyncio
from hfs.events import EventBus
from hfs.state import StateManager
from hfs.state.query import QueryInterface

async def test():
    bus = EventBus()
    mgr = StateManager(bus)
    query = QueryInterface(mgr)

    # All query methods should work on empty state
    tree = query.get_agent_tree()
    neg = query.get_negotiation_state()
    usage = query.get_token_usage()
    timeline = query.get_trace_timeline()
    snapshot = query.get_snapshot()

    print(f'Version: {query.version}')
    print(f'Triads: {len(tree.triads)}')
    print(f'Sections: {len(neg.sections)}')
    print(f'Total tokens: {usage.total_tokens}')
    print('QueryInterface basic queries OK')

asyncio.run(test())
"
  </verify>
  <done>
QueryInterface created with:
- Composite query: get_snapshot()
- Agent tree queries: get_agent_tree(), get_agent(), get_triad()
- Negotiation queries: get_negotiation_state(), get_section()
- Token usage queries: get_token_usage(), get_usage_by_phase(), get_usage_by_agent()
- Trace timeline queries: get_trace_timeline(), get_phase_timeline()
- Version property for cache invalidation
  </done>
</task>

<task type="auto">
  <name>Task 2: Add subscription support and delta queries</name>
  <files>hfs/state/query.py, hfs/state/manager.py, hfs/state/__init__.py</files>
  <action>
Add subscription support to StateManager (hfs/state/manager.py):

```python
# Add to StateManager.__init__:
self._subscribers: list[tuple[ChangeCategory, Callable[[StateChange], Awaitable[None]]]] = []

# Add methods:
def subscribe(
    self,
    callback: Callable[[StateChange], Awaitable[None]],
    category: ChangeCategory = ChangeCategory.ALL,
) -> Callable[[], None]:
    """Subscribe to state changes.

    Args:
        callback: Async function called on state changes
        category: Filter by change category (default: ALL)

    Returns:
        Unsubscribe function
    """
    entry = (category, callback)
    self._subscribers.append(entry)
    return lambda: self._subscribers.remove(entry) if entry in self._subscribers else None

async def _notify_subscribers(self, category: ChangeCategory) -> None:
    """Notify subscribers of state change."""
    change = StateChange(version=self._version, category=category)
    for sub_category, callback in list(self._subscribers):
        if sub_category == ChangeCategory.ALL or sub_category == category:
            try:
                asyncio.create_task(callback(change))
            except Exception:
                pass  # Don't let one subscriber break others

# Update _apply_event to call _notify_subscribers with appropriate category:
# - agent.started/ended -> AGENT_TREE
# - negotiation.* -> NEGOTIATION
# - usage.recorded -> USAGE
# - phase.*/run.* -> TIMELINE
```

Add delta queries to QueryInterface (hfs/state/query.py):

```python
class StateChanges(BaseModel):
    """Changes since a given version."""
    from_version: int
    to_version: int
    events_processed: int
    categories_changed: list[ChangeCategory] = Field(default_factory=list)

# Add to QueryInterface class:
def get_changes_since(self, version: int) -> StateChanges:
    """Get changes since given version for incremental updates.

    If the requested version is too old (older than event history),
    returns a StateChanges indicating full refresh needed.

    Args:
        version: The version to compare from

    Returns:
        StateChanges with events processed and categories changed
    """
    current = self._state.version
    if version >= current:
        return StateChanges(
            from_version=version,
            to_version=current,
            events_processed=0,
            categories_changed=[],
        )

    # Scan event history to find changes
    categories = set()
    events_count = 0
    for event in self._state._event_history:
        # Determine category from event type
        if event.event_type.startswith("agent."):
            categories.add(ChangeCategory.AGENT_TREE)
        elif event.event_type.startswith("negotiation."):
            categories.add(ChangeCategory.NEGOTIATION)
        elif event.event_type == "usage.recorded":
            categories.add(ChangeCategory.USAGE)
        elif event.event_type.startswith(("phase.", "run.")):
            categories.add(ChangeCategory.TIMELINE)
        events_count += 1

    return StateChanges(
        from_version=version,
        to_version=current,
        events_processed=events_count,
        categories_changed=list(categories),
    )
```

Add subscription convenience method to QueryInterface:

```python
def subscribe(
    self,
    callback: Callable[[StateChange], Awaitable[None]],
    category: ChangeCategory = ChangeCategory.ALL,
) -> Callable[[], None]:
    """Subscribe to state changes.

    Convenience wrapper around StateManager.subscribe.

    Args:
        callback: Async function called on state changes
        category: Filter by change category

    Returns:
        Unsubscribe function
    """
    return self._state.subscribe(callback, category)
```

Update hfs/state/__init__.py to export all new types:
- QueryInterface
- StateChange
- StateChanges
- ChangeCategory
  </action>
  <verify>
python -c "from hfs.state import QueryInterface, StateChange, ChangeCategory; print('All exports OK')"
python -c "
import asyncio
from hfs.events import EventBus
from hfs.events.models import AgentStartedEvent
from hfs.state import StateManager
from hfs.state.query import QueryInterface, ChangeCategory, StateChanges

async def test():
    bus = EventBus()
    mgr = StateManager(bus)
    query = QueryInterface(mgr)

    notifications = []
    async def on_change(change):
        notifications.append(change)

    unsubscribe = query.subscribe(on_change, ChangeCategory.AGENT_TREE)

    await mgr.start()

    # Emit agent event
    await bus.emit(AgentStartedEvent(
        run_id='r1', agent_id='a1', triad_id='t1', role='orchestrator'
    ))
    await asyncio.sleep(0.1)

    # Check notification received
    assert len(notifications) >= 1, 'Should receive notification'
    print(f'Notifications: {len(notifications)}')

    # Check delta query
    changes = query.get_changes_since(0)
    print(f'Changes: {changes}')
    assert changes.events_processed >= 1

    unsubscribe()
    await mgr.stop()
    print('Subscription and delta queries OK')

asyncio.run(test())
"
  </verify>
  <done>
Subscription support added:
- StateManager.subscribe() with category filtering
- StateManager._notify_subscribers() called after event processing
- QueryInterface.subscribe() convenience wrapper
- StateChanges model for delta queries
- QueryInterface.get_changes_since() for incremental updates
  </done>
</task>

</tasks>

<verification>
Run comprehensive verification:

```bash
# All exports available
python -c "from hfs.state import StateManager, QueryInterface, StateChange, ChangeCategory, RunSnapshot, AgentTree"

# JSON serialization (ABS-08)
python -c "
from hfs.state import QueryInterface, StateManager
from hfs.events import EventBus
import json

bus = EventBus()
mgr = StateManager(bus)
query = QueryInterface(mgr)

# All query results must serialize to JSON
snapshot = query.get_snapshot()
tree = query.get_agent_tree()
neg = query.get_negotiation_state()
usage = query.get_token_usage()
timeline = query.get_trace_timeline()

for name, obj in [('snapshot', snapshot), ('tree', tree), ('neg', neg), ('usage', usage), ('timeline', timeline)]:
    json_str = json.dumps(obj.model_dump(mode='json'))
    print(f'{name}: {len(json_str)} bytes')
print('All responses JSON-serializable')
"

# Integration test with events
python -c "
import asyncio
from hfs.events import EventBus
from hfs.events.models import (
    RunStartedEvent, PhaseStartedEvent, AgentStartedEvent, AgentEndedEvent,
    UsageEvent, NegotiationClaimedEvent
)
from hfs.state import StateManager, QueryInterface

async def test():
    bus = EventBus()
    mgr = StateManager(bus)
    query = QueryInterface(mgr)
    await mgr.start()

    # Simulate HFS run
    await bus.emit(RunStartedEvent(run_id='r1'))
    await bus.emit(PhaseStartedEvent(run_id='r1', phase_id='p1', phase_name='deliberation'))
    await bus.emit(AgentStartedEvent(run_id='r1', agent_id='a1', triad_id='t1', role='orchestrator'))
    await bus.emit(UsageEvent(run_id='r1', triad_id='t1', prompt_tokens=100, completion_tokens=50, model='gpt-4'))
    await bus.emit(NegotiationClaimedEvent(run_id='r1', triad_id='t1', section_name='intro'))
    await asyncio.sleep(0.2)

    # Verify all queries return expected data
    tree = query.get_agent_tree()
    assert len(tree.triads) == 1, f'Expected 1 triad, got {len(tree.triads)}'
    assert 'a1' in tree.agent_index, 'Agent a1 should be in index'

    neg = query.get_negotiation_state()
    assert len(neg.sections) == 1, f'Expected 1 section, got {len(neg.sections)}'

    usage = query.get_token_usage()
    assert usage.total_tokens == 150, f'Expected 150 tokens, got {usage.total_tokens}'

    timeline = query.get_trace_timeline()
    assert len(timeline.phases) == 1, f'Expected 1 phase, got {len(timeline.phases)}'

    await mgr.stop()
    print('Integration test passed')

asyncio.run(test())
"
```
</verification>

<success_criteria>
1. QueryInterface provides typed queries for agent tree (ABS-03)
2. QueryInterface provides negotiation state queries (ABS-04)
3. QueryInterface provides token usage queries (ABS-05)
4. QueryInterface provides trace timeline queries (ABS-06)
5. All query responses serialize to JSON (ABS-08)
6. Subscription support enables real-time widget updates
7. Delta queries enable efficient incremental updates
</success_criteria>

<output>
After completion, create `.planning/phases/09-state-query-layer/09-02-SUMMARY.md`
</output>
