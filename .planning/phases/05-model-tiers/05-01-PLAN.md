---
phase: 05-model-tiers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - hfs/core/model_tiers.py
  - hfs/config/default.yaml
autonomous: true

must_haves:
  truths:
    - "ModelTiersConfig validates tier definitions with provider-specific model IDs"
    - "TierConfig requires description and providers mapping"
    - "Default YAML includes reasoning, general, fast tiers with all 4 providers"
    - "Role defaults map orchestrator to reasoning, workers to general, code_execution to fast"
  artifacts:
    - path: "hfs/core/model_tiers.py"
      provides: "Pydantic models for model tier configuration"
      exports: ["TierConfig", "ModelTiersConfig", "TierName"]
    - path: "hfs/config/default.yaml"
      provides: "model_tiers configuration section"
      contains: "model_tiers:"
  key_links:
    - from: "hfs/core/model_tiers.py"
      to: "hfs/core/config.py"
      via: "Pydantic pattern consistency"
      pattern: "BaseModel"
---

<objective>
Create the model tiers configuration schema with Pydantic validation and extend default.yaml with tier definitions.

Purpose: Establish the foundation for role-based model selection per MODL-01 requirement.
Output: TierConfig and ModelTiersConfig Pydantic models plus YAML configuration.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-model-tiers/05-CONTEXT.md
@.planning/phases/05-model-tiers/05-RESEARCH.md
@hfs/core/config.py
@hfs/config/default.yaml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create model_tiers.py with Pydantic config models</name>
  <files>hfs/core/model_tiers.py</files>
  <action>
Create a new module with Pydantic models for model tier configuration:

1. Define `TierName = Literal["reasoning", "general", "fast"]` type alias

2. Create `TierConfig(BaseModel)`:
   - `description: str` - Human-readable tier purpose
   - `providers: Dict[str, str]` - Provider name to model ID mapping

3. Create `ModelTiersConfig(BaseModel)`:
   - `tiers: Dict[TierName, TierConfig]` - Tier name to config
   - `role_defaults: Dict[str, TierName]` - Role name to default tier (default_factory=dict)
   - `phase_overrides: Dict[str, Dict[str, TierName]]` - Phase name to role overrides (default_factory=dict)
   - `escalation_state: Dict[str, TierName]` - "triad_id:role" to escalated tier (default_factory=dict, system-managed)

4. Add model_validator to ensure all 3 tiers are defined

Follow patterns from hfs/core/config.py (Field descriptions, validators).
  </action>
  <verify>python -c "from hfs.core.model_tiers import TierConfig, ModelTiersConfig, TierName; print('Import OK')"</verify>
  <done>ModelTiersConfig can be instantiated with tier definitions, role_defaults, phase_overrides, and escalation_state</done>
</task>

<task type="auto">
  <name>Task 2: Add model_tiers section to default.yaml</name>
  <files>hfs/config/default.yaml</files>
  <action>
Add a new `model_tiers:` section to default.yaml under the `config:` key:

```yaml
  # ============================================================
  # MODEL TIERS - Role-based model selection with adaptive escalation
  # ============================================================
  model_tiers:
    # Tier definitions with provider-specific model IDs
    tiers:
      reasoning:
        description: "Highest capability for complex orchestration"
        providers:
          cerebras: "qwen-3-235b-a22b-instruct-2507"
          groq: "moonshotai/kimi-k2-instruct"
          gemini: "gemini-2.5-flash"
          openrouter: "anthropic/claude-sonnet-4"
      general:
        description: "Balanced capability for workers"
        providers:
          cerebras: "llama-3.3-70b"
          groq: "llama-3.3-70b-versatile"
          gemini: "gemini-2.5-flash-lite"
          openrouter: "meta-llama/llama-3.3-70b-instruct:free"
      fast:
        description: "Speed-optimized for code execution"
        providers:
          cerebras: "zai-glm-4.7"
          groq: "openai/gpt-oss-120b"
          gemini: "gemma-3-27b-it"
          openrouter: "meta-llama/llama-3.3-70b-instruct:free"

    # Role-to-tier defaults
    role_defaults:
      # Hierarchical triad
      orchestrator: "reasoning"
      worker_a: "general"
      worker_b: "general"
      # Dialectic triad
      proposer: "general"
      critic: "general"
      synthesizer: "reasoning"
      # Consensus triad
      peer_1: "general"
      peer_2: "general"
      peer_3: "general"
      # Special case - always fast tier
      code_execution: "fast"

    # Phase overrides (execution phase uses faster models)
    phase_overrides:
      execution:
        worker_a: "fast"
        worker_b: "fast"

    # Escalation state (system-managed, initially empty)
    escalation_state: {}
```

Place this section after the `output:` section.
  </action>
  <verify>python -c "import yaml; data = yaml.safe_load(open('hfs/config/default.yaml')); assert 'model_tiers' in data['config']; print('YAML OK')"</verify>
  <done>default.yaml contains model_tiers section with 3 tiers, role_defaults, phase_overrides, and empty escalation_state</done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for model_tiers module</name>
  <files>tests/unit/test_model_tiers.py</files>
  <action>
Create unit tests for the model_tiers Pydantic models:

1. Test TierConfig validation:
   - Valid tier with description and providers
   - Invalid tier missing required fields

2. Test ModelTiersConfig validation:
   - Valid config with all 3 tiers
   - Missing tier raises validation error
   - Empty role_defaults is allowed (defaults to empty dict)
   - phase_overrides work correctly
   - escalation_state can store "triad_id:role" keys

3. Test loading from YAML:
   - Load model_tiers section from default.yaml
   - Validate it parses into ModelTiersConfig

Use pytest, follow existing test patterns in tests/unit/.
  </action>
  <verify>pytest tests/unit/test_model_tiers.py -v</verify>
  <done>All unit tests pass for TierConfig and ModelTiersConfig validation</done>
</task>

</tasks>

<verification>
1. `python -c "from hfs.core.model_tiers import TierConfig, ModelTiersConfig"` succeeds
2. `python -c "import yaml; yaml.safe_load(open('hfs/config/default.yaml'))['config']['model_tiers']"` returns tier config
3. `pytest tests/unit/test_model_tiers.py -v` passes all tests
</verification>

<success_criteria>
- Pydantic models validate tier configurations with proper constraints
- Default YAML contains complete model_tiers section
- Unit tests verify config validation and YAML loading
- Code follows existing config.py patterns
</success_criteria>

<output>
After completion, create `.planning/phases/05-model-tiers/05-01-SUMMARY.md`
</output>
