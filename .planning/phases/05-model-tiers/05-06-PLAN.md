---
phase: 05-model-tiers
plan: 06
type: execute
wave: 1
depends_on: [05-04, 05-05]
files_modified:
  - hfs/core/orchestrator.py
  - hfs/agno/teams/base.py
  - tests/unit/test_orchestrator_model_tiers.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Orchestrator instantiates ModelSelector and EscalationTracker"
    - "Orchestrator calls create_agno_triad instead of create_triad"
    - "Phase parameter passed to _get_model_for_role at agent creation time (not runtime)"
    - "EscalationTracker records success/failure via AgnoTriad._run_with_error_handling (triads record, not orchestrator)"
  artifacts:
    - path: "hfs/core/orchestrator.py"
      provides: "ModelSelector and EscalationTracker integration"
      contains: "create_agno_triad"
    - path: "tests/unit/test_orchestrator_model_tiers.py"
      provides: "Orchestrator model tier integration tests"
      min_lines: 100
  key_links:
    - from: "hfs/core/orchestrator.py"
      to: "hfs/presets/triad_factory.create_agno_triad"
      via: "factory call in _spawn_triads"
      pattern: "create_agno_triad\\("
    - from: "hfs/core/orchestrator.py"
      to: "hfs/core/model_selector.ModelSelector"
      via: "import and instantiation"
      pattern: "ModelSelector\\("
    - from: "hfs/core/orchestrator.py"
      to: "hfs/core/escalation_tracker.EscalationTracker"
      via: "import and instantiation"
      pattern: "EscalationTracker\\("
---

<objective>
Wire ModelSelector and EscalationTracker into HFSOrchestrator, completing the Phase 5 runtime integration.

Purpose: All Phase 5 components (ModelSelector, EscalationTracker, AgnoTriad subclasses) are built and tested in isolation. This plan connects them to the orchestrator runtime so role-based model selection and failure-adaptive escalation actually occur during pipeline execution.

Output: Updated orchestrator that uses create_agno_triad() with ModelSelector, plus tests proving the integration works.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Prior phase summaries for context
@.planning/phases/05-model-tiers/05-04-SUMMARY.md
@.planning/phases/05-model-tiers/05-05-SUMMARY.md

# Key files to modify
@hfs/core/orchestrator.py
@hfs/presets/triad_factory.py
@hfs/core/model_selector.py
@hfs/core/escalation_tracker.py
</context>

<tasks>

<task type="auto">
  <name>Task 1a: Update orchestrator __init__ and add imports</name>
  <files>hfs/core/orchestrator.py</files>
  <action>
    Update HFSOrchestrator __init__ to accept ModelSelector and EscalationTracker:

    1. Add imports at the top:
       - `from .model_selector import ModelSelector`
       - `from .escalation_tracker import EscalationTracker`
       - `from ..presets.triad_factory import create_agno_triad` (add to existing import)
       - `from hfs.agno.providers import ProviderManager`
       - `from hfs.core.model_tiers import ModelTiersConfig`
       - `from pathlib import Path`

    2. Update `__init__` signature and body:
       - Add optional parameters:
         - `model_selector: Optional[ModelSelector] = None`
         - `escalation_tracker: Optional[EscalationTracker] = None`
         - `config_path: Optional[Path] = None` (to pass to EscalationTracker)
       - Store as instance attributes:
         - `self.model_selector = model_selector`
         - `self.escalation_tracker = escalation_tracker`
         - `self._config_path = config_path` (store for EscalationTracker)
  </action>
  <verify>
    Run: `python -c "from hfs.core.orchestrator import HFSOrchestrator; print('import ok')"`
    Should print "import ok" without errors.
  </verify>
  <done>
    - Imports added for ModelSelector, EscalationTracker, create_agno_triad
    - HFSOrchestrator __init__ accepts model_selector and escalation_tracker parameters
    - Parameters stored as instance attributes
  </done>
</task>

<task type="auto">
  <name>Task 1b: Add _create_default_model_selector helper and update _spawn_triads</name>
  <files>hfs/core/orchestrator.py</files>
  <action>
    Add helper method and update _spawn_triads:

    1. Add helper method `_create_default_model_selector()`:
       - Load ModelTiersConfig from self.config if model_tiers section exists
       - Create ProviderManager instance
       - Return ModelSelector(config, provider_manager)
       - This allows orchestrator to work without explicit ModelSelector if config has model_tiers

    2. Update `run()` method (LAZY INITIALIZATION - helper is called here, not in __init__):
       - At the START of run(), before any triad operations:
       - Check: `if self.model_selector is None and "model_tiers" in self.config:`
       - If true: `self.model_selector = self._create_default_model_selector()`
       - Check: `if self.escalation_tracker is None and self.model_selector is not None:`
       - If true: `self.escalation_tracker = EscalationTracker(self._config_path, self.model_selector.config)`

    3. Update `_spawn_triads()` method:
       - If `self.model_selector` is not None:
         - Call `create_agno_triad(config, self.model_selector, self.spec, self.escalation_tracker)`
         - Store result in self.triads (type hint as Union[Triad, Any] for mixed types)
       - If `self.model_selector` is None (backward compat):
         - Call existing `create_triad(config, self.llm)` as fallback

    Keep backward compatibility: If model_selector is not provided and no model_tiers in config, continue using the old create_triad path with self.llm.

    Note: EscalationTracker recording happens via triads (AgnoTriad._run_with_error_handling calls record_success/record_failure), NOT in orchestrator. Orchestrator only passes tracker to triads.
  </action>
  <verify>
    Run the following verification commands:
    - `python -c "from hfs.core.orchestrator import HFSOrchestrator; print('import ok')"`
    - `grep "create_agno_triad" hfs/core/orchestrator.py` (should show import and usage in _spawn_triads)
    - `grep "ModelSelector" hfs/core/orchestrator.py` (should show import, parameter, and usage)
    - `grep "EscalationTracker" hfs/core/orchestrator.py` (should show import, parameter, and passing to factory)
  </verify>
  <done>
    - _create_default_model_selector helper method added
    - run() method lazily initializes model_selector if config has model_tiers
    - _spawn_triads calls create_agno_triad when model_selector is available
    - Backward compatibility maintained when model_selector is None
  </done>
</task>

<task type="auto">
  <name>Task 2: Document phase parameter limitation in _get_model_for_role</name>
  <files>hfs/agno/teams/base.py</files>
  <action>
    Add documentation to _get_model_for_role explaining the phase parameter limitation.

    Location: In the docstring of `_get_model_for_role` method in `hfs/agno/teams/base.py` (around line 96-109)

    Update the docstring to include this note after the Returns section:

    ```python
    def _get_model_for_role(self, role: str, phase: Optional[str] = None) -> Model:
        """Get model for a specific agent role using ModelSelector.

        Subclasses should call this method in _create_agents() to get
        the appropriate model for each agent role.

        Args:
            role: Agent role name (e.g., "orchestrator", "worker_a")
            phase: Optional phase name for phase-specific tier overrides

        Returns:
            Agno Model instance for the specified role

        Note:
            The phase parameter currently only applies at triad instantiation time
            (when _create_agents is called), NOT at execution runtime. This is because
            Agno agents are created once with their model assignment and cannot be
            dynamically swapped during execution. For execution-phase specific models,
            use the "code_execution" role in role_defaults and call this method with
            role="code_execution" when creating agents that run during execution phase.
            Dynamic phase-based model swapping is planned for a future release.
        """
        return self.model_selector.get_model(self.config.id, role, phase)
    ```

    This documents that:
    1. Phase parameter is for future extension
    2. Models are assigned at instantiation, not runtime
    3. Workaround: use code_execution role explicitly
  </action>
  <verify>
    Run: `python -c "from hfs.agno.teams.base import AgnoTriad; print('AgnoTriad loads')"`
    Should print without errors.
  </verify>
  <done>
    - Docstring updated to explain phase parameter applies at instantiation time only
    - Workaround documented: use code_execution role for execution-specific models
    - Future extension intent documented
  </done>
</task>

<task type="auto">
  <name>Task 3: Create orchestrator model tiers integration tests</name>
  <files>tests/unit/test_orchestrator_model_tiers.py</files>
  <action>
    Create comprehensive tests for orchestrator + model tier integration:

    ```python
    """Tests for HFSOrchestrator ModelSelector integration.

    These tests verify that the orchestrator correctly integrates with
    ModelSelector and EscalationTracker for role-based model selection.
    """

    import pytest
    from unittest.mock import Mock, MagicMock, patch
    from pathlib import Path

    from hfs.core.orchestrator import HFSOrchestrator
    from hfs.core.model_selector import ModelSelector
    from hfs.core.escalation_tracker import EscalationTracker
    from hfs.core.model_tiers import ModelTiersConfig, TierConfig


    @pytest.fixture
    def minimal_config_dict():
        """Minimal valid HFS config dict for testing."""
        return {
            "config": {
                "triads": [
                    {
                        "id": "test_triad",
                        "preset": "hierarchical",
                        "scope": {"primary": ["layout"], "reach": ["spacing"]},
                        "budget": {"tokens": 1000, "tool_calls": 10, "time_ms": 5000},
                        "objectives": ["test"],
                    }
                ],
                "sections": [{"name": "layout"}, {"name": "spacing"}],
                "pressure": {
                    "initial_temperature": 0.5,
                    "cooling_rate": 0.1,
                    "threshold": 0.9,
                },
                "arbiter": {"model": "test", "max_tokens": 100, "temperature": 0.5},
                "output": {"format": "json"},
            }
        }


    @pytest.fixture
    def model_tiers_config():
        """ModelTiersConfig for testing."""
        return ModelTiersConfig(
            tiers={
                "reasoning": TierConfig(
                    description="high",
                    providers={"cerebras": "llama-3.3-70b"},
                ),
                "general": TierConfig(
                    description="mid",
                    providers={"cerebras": "llama-3.1-8b-instant"},
                ),
                "fast": TierConfig(
                    description="low",
                    providers={"cerebras": "llama-3.1-8b-instant"},
                ),
            },
            role_defaults={
                "orchestrator": "reasoning",
                "worker_a": "general",
                "worker_b": "general",
            },
            phase_overrides={},
            escalation_state={},
        )


    @pytest.fixture
    def mock_provider_manager():
        """Mock ProviderManager for testing."""
        manager = Mock()
        manager.available_providers = ["cerebras"]
        manager.get_model.return_value = Mock()
        return manager


    @pytest.fixture
    def mock_model_selector(model_tiers_config, mock_provider_manager):
        """Mock ModelSelector for testing."""
        selector = ModelSelector(model_tiers_config, mock_provider_manager)
        return selector


    class TestOrchestratorModelSelectorInit:
        """Tests for orchestrator initialization with ModelSelector."""

        def test_accepts_model_selector_parameter(
            self, minimal_config_dict, mock_model_selector
        ):
            """Orchestrator should accept model_selector parameter."""
            orch = HFSOrchestrator(
                config_dict=minimal_config_dict,
                llm_client=Mock(),
                model_selector=mock_model_selector,
            )
            assert orch.model_selector is mock_model_selector

        def test_accepts_escalation_tracker_parameter(
            self, minimal_config_dict, mock_model_selector, model_tiers_config, tmp_path
        ):
            """Orchestrator should accept escalation_tracker parameter."""
            config_path = tmp_path / "config.yaml"
            config_path.write_text("config: {}")
            tracker = EscalationTracker(config_path, model_tiers_config)

            orch = HFSOrchestrator(
                config_dict=minimal_config_dict,
                llm_client=Mock(),
                model_selector=mock_model_selector,
                escalation_tracker=tracker,
            )
            assert orch.escalation_tracker is tracker

        def test_backward_compat_without_model_selector(self, minimal_config_dict):
            """Orchestrator should work without model_selector for backward compat."""
            orch = HFSOrchestrator(
                config_dict=minimal_config_dict,
                llm_client=Mock(),
            )
            assert orch.model_selector is None


    class TestOrchestratorSpawnTriads:
        """Tests for _spawn_triads with ModelSelector."""

        @patch("hfs.core.orchestrator.create_agno_triad")
        def test_calls_create_agno_triad_when_model_selector_provided(
            self, mock_create_agno, minimal_config_dict, mock_model_selector
        ):
            """_spawn_triads should call create_agno_triad when model_selector exists."""
            mock_triad = Mock()
            mock_create_agno.return_value = mock_triad

            orch = HFSOrchestrator(
                config_dict=minimal_config_dict,
                llm_client=Mock(),
                model_selector=mock_model_selector,
            )
            orch._spawn_triads()

            mock_create_agno.assert_called_once()
            # Verify model_selector was passed
            call_kwargs = mock_create_agno.call_args
            assert call_kwargs[0][1] is mock_model_selector  # Second positional arg

        @patch("hfs.core.orchestrator.create_triad")
        def test_calls_create_triad_when_no_model_selector(
            self, mock_create_triad, minimal_config_dict
        ):
            """_spawn_triads should call create_triad when no model_selector."""
            mock_triad = Mock()
            mock_create_triad.return_value = mock_triad

            orch = HFSOrchestrator(
                config_dict=minimal_config_dict,
                llm_client=Mock(),
            )
            orch._spawn_triads()

            mock_create_triad.assert_called_once()

        @patch("hfs.core.orchestrator.create_agno_triad")
        def test_passes_spec_to_create_agno_triad(
            self, mock_create_agno, minimal_config_dict, mock_model_selector
        ):
            """create_agno_triad should receive the shared spec instance."""
            mock_create_agno.return_value = Mock()

            orch = HFSOrchestrator(
                config_dict=minimal_config_dict,
                llm_client=Mock(),
                model_selector=mock_model_selector,
            )
            orch._spawn_triads()

            # Verify spec was passed (third positional arg)
            call_args = mock_create_agno.call_args[0]
            assert call_args[2] is orch.spec

        @patch("hfs.core.orchestrator.create_agno_triad")
        def test_passes_escalation_tracker_to_create_agno_triad(
            self, mock_create_agno, minimal_config_dict, mock_model_selector,
            model_tiers_config, tmp_path
        ):
            """create_agno_triad should receive escalation_tracker if provided."""
            mock_create_agno.return_value = Mock()
            config_path = tmp_path / "config.yaml"
            config_path.write_text("config: {}")
            tracker = EscalationTracker(config_path, model_tiers_config)

            orch = HFSOrchestrator(
                config_dict=minimal_config_dict,
                llm_client=Mock(),
                model_selector=mock_model_selector,
                escalation_tracker=tracker,
            )
            orch._spawn_triads()

            # Verify escalation_tracker was passed
            call_kwargs = mock_create_agno.call_args[1]
            assert call_kwargs.get("escalation_tracker") is tracker


    class TestOrchestratorBackwardCompatibility:
        """Tests ensuring backward compatibility is maintained."""

        def test_llm_client_still_stored(self, minimal_config_dict):
            """self.llm should still be stored for backward compat."""
            mock_llm = Mock()
            orch = HFSOrchestrator(
                config_dict=minimal_config_dict,
                llm_client=mock_llm,
            )
            assert orch.llm is mock_llm

        def test_triads_dict_populated(self, minimal_config_dict, mock_model_selector):
            """self.triads dict should be populated after _spawn_triads."""
            with patch("hfs.core.orchestrator.create_agno_triad") as mock_create:
                mock_create.return_value = Mock()
                orch = HFSOrchestrator(
                    config_dict=minimal_config_dict,
                    llm_client=Mock(),
                    model_selector=mock_model_selector,
                )
                orch._spawn_triads()

            assert "test_triad" in orch.triads
    ```

    Write this test file. The tests verify:
    - Orchestrator accepts ModelSelector parameter
    - Orchestrator accepts EscalationTracker parameter
    - _spawn_triads calls create_agno_triad when model_selector provided
    - _spawn_triads calls create_triad when no model_selector (backward compat)
    - Spec and escalation_tracker passed correctly to factory
  </action>
  <verify>
    Run: `pytest tests/unit/test_orchestrator_model_tiers.py -v`
    All tests should pass.
  </verify>
  <done>
    - Test file created with comprehensive coverage
    - Tests verify ModelSelector integration
    - Tests verify backward compatibility
    - All tests pass
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Import check:
   ```bash
   python -c "from hfs.core.orchestrator import HFSOrchestrator; from hfs.core.model_selector import ModelSelector; print('imports ok')"
   ```

2. Run all model tier tests:
   ```bash
   pytest tests/unit/test_model_tier*.py tests/unit/test_orchestrator_model_tiers.py -v
   ```

3. Verify create_agno_triad is called:
   ```bash
   grep -n "create_agno_triad" hfs/core/orchestrator.py
   ```
   Should show the import and usage in _spawn_triads.

4. Run full test suite to ensure no regressions:
   ```bash
   pytest tests/unit/ -v --tb=short
   ```
</verification>

<success_criteria>
- HFSOrchestrator accepts model_selector and escalation_tracker parameters
- _spawn_triads calls create_agno_triad when model_selector is provided
- Backward compatibility maintained (create_triad used when no model_selector)
- All existing tests pass (no regressions)
- New integration tests pass
- create_agno_triad import and call visible in orchestrator.py
</success_criteria>

<output>
After completion, create `.planning/phases/05-model-tiers/05-06-SUMMARY.md`
</output>
