---
phase: 05-model-tiers
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - hfs/core/escalation_tracker.py
  - tests/unit/test_escalation_tracker.py
autonomous: true

must_haves:
  truths:
    - "EscalationTracker records failures and triggers tier upgrade at threshold"
    - "3 consecutive failures for same triad:role triggers escalation"
    - "Escalation persists to YAML config file using ruamel.yaml"
    - "No de-escalation - once upgraded, stays upgraded"
    - "Success resets failure count (within same tier)"
  artifacts:
    - path: "hfs/core/escalation_tracker.py"
      provides: "Failure tracking and permanent config escalation"
      exports: ["EscalationTracker"]
    - path: "tests/unit/test_escalation_tracker.py"
      provides: "Unit tests for escalation logic"
      min_lines: 60
  key_links:
    - from: "hfs/core/escalation_tracker.py"
      to: "hfs/core/model_tiers.py"
      via: "ModelTiersConfig updates"
      pattern: "escalation_state"
    - from: "hfs/core/escalation_tracker.py"
      to: "hfs/config/default.yaml"
      via: "ruamel.yaml round-trip editing"
      pattern: "YAML\\(\\)"
---

<objective>
Create the EscalationTracker class that tracks failures and permanently upgrades model tiers in the config file.

Purpose: Implement adaptive model escalation per MODL-04 requirement - self-improving config evolution.
Output: EscalationTracker class with record_failure(), record_success(), and persistent config updates.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-model-tiers/05-CONTEXT.md
@.planning/phases/05-model-tiers/05-RESEARCH.md
@.planning/phases/05-model-tiers/05-01-SUMMARY.md
@hfs/core/model_tiers.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install ruamel.yaml dependency</name>
  <files>pyproject.toml</files>
  <action>
Add ruamel.yaml to project dependencies in pyproject.toml:

```
ruamel.yaml>=0.18.0
```

Then run: `pip install ruamel.yaml`

This library enables round-trip YAML editing that preserves comments and formatting.
  </action>
  <verify>python -c "from ruamel.yaml import YAML; print('ruamel.yaml OK')"</verify>
  <done>ruamel.yaml is installed and importable</done>
</task>

<task type="auto">
  <name>Task 2: Create EscalationTracker class</name>
  <files>hfs/core/escalation_tracker.py</files>
  <action>
Create the EscalationTracker class for failure tracking and permanent tier upgrades:

```python
class EscalationTracker:
    """Tracks failures and triggers permanent tier upgrades."""

    ESCALATION_THRESHOLD = 3  # Consecutive failures before escalation
    TIER_ORDER = ["fast", "general", "reasoning"]  # Escalation path

    def __init__(self, config_path: Path, config: ModelTiersConfig):
        self.config_path = config_path
        self.config = config
        self._failure_counts: Dict[str, int] = defaultdict(int)

    def record_failure(self, triad_id: str, role: str) -> Optional[str]:
        """Record failure, return new tier if escalation triggered."""
        key = f"{triad_id}:{role}"
        self._failure_counts[key] += 1
        logger.debug(f"Failure recorded for {key}: {self._failure_counts[key]}/{self.ESCALATION_THRESHOLD}")

        if self._failure_counts[key] >= self.ESCALATION_THRESHOLD:
            new_tier = self._escalate(key, role)
            self._failure_counts[key] = 0  # Reset after escalation
            return new_tier
        return None

    def record_success(self, triad_id: str, role: str) -> None:
        """Reset failure count on success (within same tier)."""
        key = f"{triad_id}:{role}"
        if self._failure_counts[key] > 0:
            logger.debug(f"Success recorded for {key}, resetting failure count")
            self._failure_counts[key] = 0

    def _escalate(self, key: str, role: str) -> Optional[str]:
        """Upgrade to next tier, persist to config file."""
        # Get current tier (from escalation_state or role_defaults)
        current = self.config.escalation_state.get(
            key,
            self.config.role_defaults.get(role, "general")
        )

        try:
            current_idx = self.TIER_ORDER.index(current)
        except ValueError:
            logger.warning(f"Unknown tier '{current}' for {key}, treating as 'general'")
            current_idx = self.TIER_ORDER.index("general")

        if current_idx >= len(self.TIER_ORDER) - 1:
            logger.warning(f"{key} already at highest tier ({current}), cannot escalate")
            return None

        new_tier = self.TIER_ORDER[current_idx + 1]
        logger.info(f"Escalating {key}: {current} -> {new_tier}")

        # Update in-memory config
        self.config.escalation_state[key] = new_tier

        # Persist to file
        self._persist_escalation(key, new_tier)
        return new_tier

    def _persist_escalation(self, key: str, tier: str) -> None:
        """Update YAML config file with new escalation state."""
        from ruamel.yaml import YAML
        yaml = YAML()
        yaml.preserve_quotes = True

        with open(self.config_path, 'r') as f:
            data = yaml.load(f)

        # Navigate to escalation_state, creating path if needed
        if 'config' not in data:
            data['config'] = {}
        if 'model_tiers' not in data['config']:
            data['config']['model_tiers'] = {}
        if 'escalation_state' not in data['config']['model_tiers']:
            data['config']['model_tiers']['escalation_state'] = {}

        data['config']['model_tiers']['escalation_state'][key] = tier

        with open(self.config_path, 'w') as f:
            yaml.dump(data, f)

        logger.debug(f"Persisted escalation state for {key} to {self.config_path}")

    def get_failure_count(self, triad_id: str, role: str) -> int:
        """Get current failure count for a triad:role."""
        return self._failure_counts.get(f"{triad_id}:{role}", 0)
```

Include proper logging and type hints.
Import from collections (defaultdict), pathlib (Path), typing (Dict, Optional).
  </action>
  <verify>python -c "from hfs.core.escalation_tracker import EscalationTracker; print('Import OK')"</verify>
  <done>EscalationTracker class can track failures, trigger escalations, and persist to YAML</done>
</task>

<task type="auto">
  <name>Task 3: Create unit tests for EscalationTracker</name>
  <files>tests/unit/test_escalation_tracker.py</files>
  <action>
Create unit tests for EscalationTracker:

1. Test failure counting:
   - record_failure increments count
   - Count persists across multiple calls
   - Different triad:role keys tracked separately

2. Test escalation trigger:
   - No escalation before threshold (2 failures)
   - Escalation at threshold (3 failures)
   - Failure count resets after escalation

3. Test success handling:
   - record_success resets failure count to 0
   - Success on key with 0 failures is no-op

4. Test tier progression:
   - fast -> general -> reasoning
   - At reasoning tier, cannot escalate (returns None, logs warning)

5. Test config persistence:
   - Mock/temp file for YAML writing
   - Verify escalation_state updated in file
   - Round-trip preserves other config content

Use pytest fixtures, tmp_path for config file testing.
Use unittest.mock for logging verification where helpful.
  </action>
  <verify>pytest tests/unit/test_escalation_tracker.py -v</verify>
  <done>All unit tests pass for failure tracking, escalation logic, and config persistence</done>
</task>

</tasks>

<verification>
1. `python -c "from ruamel.yaml import YAML"` succeeds
2. `python -c "from hfs.core.escalation_tracker import EscalationTracker"` succeeds
3. `pytest tests/unit/test_escalation_tracker.py -v` passes all tests
4. YAML config preserves comments after escalation update
</verification>

<success_criteria>
- EscalationTracker correctly tracks failures per triad:role
- Escalation triggers at 3 consecutive failures
- Tier progression follows fast -> general -> reasoning path
- YAML updates preserve existing content and comments
- Unit tests cover all escalation scenarios
</success_criteria>

<output>
After completion, create `.planning/phases/05-model-tiers/05-03-SUMMARY.md`
</output>
