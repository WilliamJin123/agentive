---
phase: 05-model-tiers
plan: 04
type: execute
wave: 1
depends_on: ["05-01", "05-02", "05-03"]
files_modified:
  - hfs/agno/teams/base.py
  - hfs/presets/triad_factory.py
  - tests/unit/test_model_tier_integration.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "AgnoTriad base class provides _get_model_for_role(role, phase) helper method"
    - "AgnoTriad accepts model_selector instead of single model in __init__"
    - "AgnoTriad accepts optional escalation_tracker parameter"
    - "Phase context available for ModelSelector tier resolution via phase parameter"
    - "_run_with_error_handling records success/failure via EscalationTracker"
    - "Triad factory provides create_agno_triad() for new API alongside legacy create_triad()"
  artifacts:
    - path: "hfs/agno/teams/base.py"
      provides: "AgnoTriad with ModelSelector and EscalationTracker integration"
      contains: "_get_model_for_role"
    - path: "hfs/presets/triad_factory.py"
      provides: "Factory with create_agno_triad for ModelSelector-based triads"
      contains: "create_agno_triad"
    - path: "tests/unit/test_model_tier_integration.py"
      provides: "Integration tests for model tier wiring"
      min_lines: 100
  key_links:
    - from: "hfs/agno/teams/base.py"
      to: "hfs/core/model_selector.py"
      via: "import and method calls"
      pattern: "from hfs\\.core\\.model_selector import ModelSelector"
    - from: "hfs/agno/teams/base.py"
      to: "hfs/core/escalation_tracker.py"
      via: "import and method calls"
      pattern: "escalation_tracker\\.record_"
    - from: "hfs/presets/triad_factory.py"
      to: "hfs/core/model_selector.py"
      via: "import and parameter passing"
      pattern: "model_selector: ModelSelector"
---

<objective>
Wire ModelSelector and EscalationTracker into AgnoTriad base class infrastructure

Purpose: Phase 05 created excellent model tier components (ModelTiersConfig, ModelSelector, EscalationTracker) but they are orphaned - not connected to the application. This plan wires them into the AgnoTriad BASE CLASS only, establishing the infrastructure pattern. Subclass updates are deferred to 05-05.

Output:
- AgnoTriad base class accepts ModelSelector + EscalationTracker parameters
- AgnoTriad provides _get_model_for_role(role, phase) helper method for subclasses
- _run_with_error_handling records success/failure via EscalationTracker
- Triad factory has new create_agno_triad() function for ModelSelector API
- Legacy create_triad() preserved for backward compatibility
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-model-tiers/05-01-SUMMARY.md
@.planning/phases/05-model-tiers/05-02-SUMMARY.md
@.planning/phases/05-model-tiers/05-03-SUMMARY.md

# Key source files to modify
@hfs/agno/teams/base.py
@hfs/presets/triad_factory.py
@hfs/core/model_selector.py
@hfs/core/escalation_tracker.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update AgnoTriad base class for ModelSelector integration</name>
  <files>hfs/agno/teams/base.py</files>
  <action>
Modify AgnoTriad to use ModelSelector for role-specific model selection:

1. **Add imports at top of file:**
   ```python
   from typing import Optional
   from hfs.core.model_selector import ModelSelector
   from hfs.core.escalation_tracker import EscalationTracker
   ```

2. **Update __init__ signature and body:**
   - Change from `model: Model` to `model_selector: ModelSelector`
   - Add optional `escalation_tracker: Optional[EscalationTracker] = None` parameter
   - Store as instance attributes: `self.model_selector = model_selector` and `self.escalation_tracker = escalation_tracker`
   - KEEP `self.model` temporarily for backward compat - set to None (subclasses will override)
   - Update docstring to document new parameters

3. **Add _get_model_for_role helper method BEFORE _create_agents:**
   ```python
   def _get_model_for_role(self, role: str, phase: Optional[str] = None) -> Model:
       """Get model for a specific agent role using ModelSelector.

       Subclasses should call this method in _create_agents() to get
       the appropriate model for each agent role.

       Args:
           role: Agent role name (e.g., "orchestrator", "worker_a")
           phase: Optional phase name for phase-specific tier overrides

       Returns:
           Agno Model instance for the specified role
       """
       return self.model_selector.get_model(self.config.id, role, phase)
   ```

4. **Update _create_agents docstring:**
   Add note: "Subclasses should call self._get_model_for_role(role_name) to get models for each agent."

5. **Modify _run_with_error_handling to record success/failure:**

   Current signature: `async def _run_with_error_handling(self, phase: str, prompt: str) -> Any:`

   After `response = await self.team.arun(prompt)` and before `return response`, add:
   ```python
   # Record success for all agent roles if tracker exists
   if self.escalation_tracker is not None:
       for role in self.agents.keys():
           self.escalation_tracker.record_success(self.config.id, role)
   ```

   In the except block, BEFORE `raise TriadExecutionError(...)`, add:
   ```python
   # Record failure if tracker exists
   if self.escalation_tracker is not None:
       # Record failure for team-level error
       self.escalation_tracker.record_failure(self.config.id, "team")
   ```

**IMPORTANT:** Do NOT modify subclasses (HierarchicalAgnoTriad, etc.) in this task. The base class changes establish the infrastructure. Subclass updates are planned for 05-05.

Note: After this change, subclasses will fail to instantiate because they still pass `model: Model` to super().__init__. This is expected - 05-05 will fix subclasses.
  </action>
  <verify>
- `grep "model_selector: ModelSelector" hfs/agno/teams/base.py` shows new parameter
- `grep "escalation_tracker: Optional" hfs/agno/teams/base.py` shows tracker parameter
- `grep "_get_model_for_role" hfs/agno/teams/base.py` shows helper method
- `grep "record_success" hfs/agno/teams/base.py` shows success recording
- `grep "record_failure" hfs/agno/teams/base.py` shows failure recording
  </verify>
  <done>
AgnoTriad base class accepts ModelSelector + EscalationTracker, provides _get_model_for_role helper, records success/failure after phase execution via _run_with_error_handling
  </done>
</task>

<task type="auto">
  <name>Task 2: Add create_agno_triad to factory (preserve legacy API)</name>
  <files>hfs/presets/triad_factory.py</files>
  <action>
Add a NEW function for the Agno triad API while preserving the legacy create_triad() function:

1. **Add imports:**
   ```python
   from typing import Optional
   from hfs.core.model_selector import ModelSelector
   from hfs.core.escalation_tracker import EscalationTracker
   ```

2. **Add import for AgnoTriad classes (at top with other imports):**
   ```python
   from hfs.agno.teams.hierarchical import HierarchicalAgnoTriad
   from hfs.agno.teams.dialectic import DialecticAgnoTriad
   from hfs.agno.teams.consensus import ConsensusAgnoTriad
   ```

3. **Add AGNO_TRIAD_REGISTRY after existing TRIAD_REGISTRY:**
   ```python
   # Registry mapping preset types to Agno-based triad classes
   AGNO_TRIAD_REGISTRY: Dict[TriadPreset, Type] = {
       TriadPreset.HIERARCHICAL: HierarchicalAgnoTriad,
       TriadPreset.DIALECTIC: DialecticAgnoTriad,
       TriadPreset.CONSENSUS: ConsensusAgnoTriad,
   }
   ```

4. **Add create_agno_triad function:**
   ```python
   def create_agno_triad(
       config: TriadConfig,
       model_selector: ModelSelector,
       spec: Any,
       escalation_tracker: Optional[EscalationTracker] = None,
   ) -> Any:  # Returns AgnoTriad but avoiding circular import
       """Create an Agno-based triad instance with ModelSelector.

       Factory function for the new ModelSelector-based API. Uses
       AGNO_TRIAD_REGISTRY to instantiate the correct AgnoTriad subclass.

       Note: This is a SEPARATE API from create_triad() which uses the
       legacy single-model approach. Use this for new code.

       Args:
           config: TriadConfig specifying the preset type and settings
           model_selector: ModelSelector for role-based model resolution
           spec: Shared Spec instance for claim/negotiation operations
           escalation_tracker: Optional tracker for failure-adaptive escalation

       Returns:
           An instance of the appropriate AgnoTriad subclass

       Raises:
           ValueError: If the preset type is not recognized
       """
       preset = config.preset

       if preset not in AGNO_TRIAD_REGISTRY:
           valid_presets = [p.value for p in TriadPreset]
           raise ValueError(
               f"Unknown triad preset: {preset}. "
               f"Valid presets are: {valid_presets}"
           )

       triad_class = AGNO_TRIAD_REGISTRY[preset]
       return triad_class(
           config=config,
           model_selector=model_selector,
           spec=spec,
           escalation_tracker=escalation_tracker,
       )
   ```

5. **DO NOT modify existing create_triad() or create_triad_from_dict().**
   The legacy API continues to work with the old Triad classes.

6. **Add docstring note to module docstring:**
   Add at end of module docstring: "Use create_agno_triad() for ModelSelector-based triads (new API)."
  </action>
  <verify>
- `grep "def create_agno_triad" hfs/presets/triad_factory.py` shows new function
- `grep "model_selector: ModelSelector" hfs/presets/triad_factory.py` shows new parameter
- `grep "escalation_tracker: Optional" hfs/presets/triad_factory.py` shows tracker parameter
- `grep "AGNO_TRIAD_REGISTRY" hfs/presets/triad_factory.py` shows new registry
- `grep "def create_triad" hfs/presets/triad_factory.py` still shows legacy function (preserved)
  </verify>
  <done>
Triad factory has create_agno_triad() for new ModelSelector API, legacy create_triad() preserved
  </done>
</task>

<task type="auto">
  <name>Task 3: Create integration tests for model tier wiring</name>
  <files>tests/unit/test_model_tier_integration.py</files>
  <action>
Create integration tests that verify the wiring at BOTH signature AND behavior level:

```python
"""Integration tests for model tier wiring into AgnoTriad.

Tests that ModelSelector and EscalationTracker are properly connected
to the triad execution flow. Includes both signature checks and
behavioral mocking tests.
"""

import pytest
import inspect
from pathlib import Path
from unittest.mock import Mock, MagicMock, patch, AsyncMock
import tempfile
import shutil

from hfs.core.model_tiers import ModelTiersConfig, TierConfig
from hfs.core.model_selector import ModelSelector
from hfs.core.escalation_tracker import EscalationTracker
from hfs.agno.teams.base import AgnoTriad
from hfs.core.triad import TriadConfig, TriadPreset


# ============================================================
# Test fixtures
# ============================================================

@pytest.fixture
def sample_tiers_config():
    """Create a minimal ModelTiersConfig for testing."""
    return ModelTiersConfig(
        tiers={
            "reasoning": TierConfig(
                description="High capability",
                providers={"cerebras": "llama-3.3-70b"}
            ),
            "general": TierConfig(
                description="Balanced",
                providers={"cerebras": "llama-3.1-8b"}
            ),
            "fast": TierConfig(
                description="Quick",
                providers={"cerebras": "llama-3.1-8b"}
            ),
        },
        role_defaults={
            "orchestrator": "reasoning",
            "worker_a": "general",
            "worker_b": "general",
            "code_execution": "fast",
        },
        phase_overrides={
            "execution": {"worker_a": "fast", "worker_b": "fast"}
        },
        escalation_state={},
    )


@pytest.fixture
def mock_provider_manager():
    """Create a mock ProviderManager."""
    manager = Mock()
    manager.available_providers = ["cerebras"]
    manager.get_model = Mock(return_value=Mock())
    return manager


@pytest.fixture
def model_selector(sample_tiers_config, mock_provider_manager):
    """Create ModelSelector with test config."""
    return ModelSelector(sample_tiers_config, mock_provider_manager)


@pytest.fixture
def temp_config_dir():
    """Create temporary config directory."""
    temp_dir = tempfile.mkdtemp()
    yield Path(temp_dir)
    shutil.rmtree(temp_dir)


@pytest.fixture
def escalation_tracker(temp_config_dir, sample_tiers_config):
    """Create EscalationTracker with temp config file."""
    config_path = temp_config_dir / "default.yaml"
    config_path.write_text("""
config:
  model_tiers:
    escalation_state: {}
""")
    return EscalationTracker(config_path, sample_tiers_config)


# ============================================================
# Signature tests (verify API contracts)
# ============================================================

class TestAgnoTriadSignature:
    """Test that AgnoTriad has correct method signatures."""

    def test_init_accepts_model_selector(self):
        """AgnoTriad.__init__ should accept model_selector parameter."""
        sig = inspect.signature(AgnoTriad.__init__)
        params = list(sig.parameters.keys())
        assert "model_selector" in params, "AgnoTriad.__init__ should accept model_selector"

    def test_init_accepts_escalation_tracker(self):
        """AgnoTriad.__init__ should accept optional escalation_tracker parameter."""
        sig = inspect.signature(AgnoTriad.__init__)
        params = list(sig.parameters.keys())
        assert "escalation_tracker" in params, "AgnoTriad.__init__ should accept escalation_tracker"

    def test_has_get_model_for_role_method(self):
        """AgnoTriad should have _get_model_for_role helper method."""
        assert hasattr(AgnoTriad, "_get_model_for_role"), "AgnoTriad should have _get_model_for_role method"

    def test_get_model_for_role_signature(self):
        """_get_model_for_role should accept role and optional phase."""
        sig = inspect.signature(AgnoTriad._get_model_for_role)
        params = list(sig.parameters.keys())
        assert "role" in params, "_get_model_for_role should accept role"
        assert "phase" in params, "_get_model_for_role should accept phase"


class TestTriadFactorySignature:
    """Test that triad factory has correct function signatures."""

    def test_create_agno_triad_exists(self):
        """create_agno_triad function should exist."""
        from hfs.presets.triad_factory import create_agno_triad
        assert callable(create_agno_triad)

    def test_create_agno_triad_accepts_model_selector(self):
        """create_agno_triad should accept model_selector parameter."""
        from hfs.presets.triad_factory import create_agno_triad
        sig = inspect.signature(create_agno_triad)
        params = list(sig.parameters.keys())
        assert "model_selector" in params, "create_agno_triad should accept model_selector"

    def test_create_agno_triad_accepts_escalation_tracker(self):
        """create_agno_triad should accept escalation_tracker parameter."""
        from hfs.presets.triad_factory import create_agno_triad
        sig = inspect.signature(create_agno_triad)
        params = list(sig.parameters.keys())
        assert "escalation_tracker" in params, "create_agno_triad should accept escalation_tracker"

    def test_legacy_create_triad_preserved(self):
        """Legacy create_triad should still exist with llm_client parameter."""
        from hfs.presets.triad_factory import create_triad
        sig = inspect.signature(create_triad)
        params = list(sig.parameters.keys())
        assert "llm_client" in params, "Legacy create_triad should have llm_client"


# ============================================================
# Behavioral tests (verify runtime behavior with mocks)
# ============================================================

class TestModelSelectorBehavior:
    """Test that ModelSelector.get_model is called correctly."""

    def test_get_model_for_role_calls_selector(self, model_selector):
        """_get_model_for_role should delegate to model_selector.get_model."""
        # Create a concrete subclass for testing
        class TestTriad(AgnoTriad):
            def _create_agents(self):
                return {"test": Mock()}
            def _create_team(self):
                return Mock()
            def _get_phase_summary_prompt(self, phase):
                return ""
            def _build_deliberation_prompt(self, user_request, spec_state):
                return ""
            def _build_negotiation_prompt(self, section, other_proposals):
                return ""
            def _build_execution_prompt(self, frozen_spec):
                return ""

        # Mock the model_selector.get_model
        model_selector.get_model = Mock(return_value=Mock())

        config = TriadConfig(
            id="test_triad",
            preset=TriadPreset.HIERARCHICAL,
            scope_primary=["test"],
            scope_reach=[],
            budget_tokens=1000,
            budget_tool_calls=10,
            budget_time_ms=5000,
            objectives=["test"],
        )
        mock_spec = Mock()

        # This will fail until subclasses are updated (expected)
        # triad = TestTriad(config=config, model_selector=model_selector, spec=mock_spec)
        # model = triad._get_model_for_role("orchestrator", "deliberation")

        # For now, just verify the method exists and has correct signature
        assert hasattr(AgnoTriad, "_get_model_for_role")


class TestEscalationTrackerBehavior:
    """Test that EscalationTracker is called on success/failure."""

    def test_escalation_tracker_stored(self, model_selector, escalation_tracker):
        """AgnoTriad should store escalation_tracker as instance attribute."""
        # Verify by checking the __init__ signature accepts it
        sig = inspect.signature(AgnoTriad.__init__)
        params = sig.parameters
        assert "escalation_tracker" in params
        # Default should be None
        assert params["escalation_tracker"].default is None


class TestCodeExecutionFastTier:
    """Test that code_execution role maps to fast tier (MODL-03)."""

    def test_code_execution_default_is_fast(self, sample_tiers_config):
        """role_defaults should map code_execution to fast tier."""
        assert sample_tiers_config.role_defaults.get("code_execution") == "fast", \
            "code_execution role should default to fast tier per MODL-03"

    def test_model_selector_returns_fast_for_code_execution(self, model_selector, mock_provider_manager):
        """ModelSelector should return fast tier model for code_execution role."""
        # Reset mock to track calls
        mock_provider_manager.get_model.reset_mock()

        # Get model for code_execution role
        model_selector.get_model("any_triad", "code_execution")

        # Verify get_model was called with fast tier model
        mock_provider_manager.get_model.assert_called_once()
        call_args = mock_provider_manager.get_model.call_args
        # Should be cerebras provider (first available) with fast tier model
        assert call_args[0][0] == "cerebras"
        assert call_args[0][1] == "llama-3.1-8b"  # fast tier model in test config
```

Run tests: `pytest tests/unit/test_model_tier_integration.py -v`
  </action>
  <verify>
- `pytest tests/unit/test_model_tier_integration.py -v` - all tests pass
- Test file exists and has at least 100 lines
- `grep "code_execution" tests/unit/test_model_tier_integration.py` shows MODL-03 test
- `grep "record_success\|record_failure" tests/unit/test_model_tier_integration.py` shows tracker tests
  </verify>
  <done>
Integration tests verify:
- AgnoTriad accepts ModelSelector + EscalationTracker parameters
- AgnoTriad has _get_model_for_role helper method
- create_agno_triad exists with new API
- Legacy create_triad preserved
- code_execution role maps to fast tier (MODL-03)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Import chain established:**
   ```bash
   grep "from hfs.core.model_selector import" hfs/agno/teams/base.py
   grep "from hfs.core.escalation_tracker import" hfs/agno/teams/base.py
   grep "from hfs.core.model_selector import" hfs/presets/triad_factory.py
   ```

2. **All tests pass:**
   ```bash
   pytest tests/unit/test_model_tier*.py -v
   ```

3. **Key wiring verified:**
   ```bash
   grep "_get_model_for_role" hfs/agno/teams/base.py
   grep "record_success\|record_failure" hfs/agno/teams/base.py
   grep "create_agno_triad" hfs/presets/triad_factory.py
   ```

4. **MODL-03 verification:**
   ```bash
   grep "code_execution.*fast" hfs/config/default.yaml
   pytest tests/unit/test_model_tier_integration.py::TestCodeExecutionFastTier -v
   ```
</verification>

<success_criteria>
- AgnoTriad base class accepts ModelSelector instead of single Model
- AgnoTriad accepts optional EscalationTracker parameter
- AgnoTriad has _get_model_for_role(role, phase) helper method
- _run_with_error_handling records success for all roles via self.agents.keys()
- _run_with_error_handling records failure for "team" on exception
- Triad factory has create_agno_triad() function (new API)
- Legacy create_triad() preserved for backward compatibility
- Integration tests verify signatures AND behavior (with mocks)
- MODL-03 verified: code_execution role maps to fast tier
- Existing unit tests for model_selector and escalation_tracker still pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-model-tiers/05-04-SUMMARY.md`
</output>
