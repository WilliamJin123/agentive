---
phase: 05-model-tiers
plan: 05
type: execute
wave: 2
depends_on: ["05-04"]
files_modified:
  - hfs/agno/teams/hierarchical.py
  - hfs/agno/teams/dialectic.py
  - hfs/agno/teams/consensus.py
  - tests/unit/test_agno_triad_subclasses.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "HierarchicalAgnoTriad uses _get_model_for_role to get models for orchestrator, worker_a, worker_b"
    - "DialecticAgnoTriad uses _get_model_for_role to get models for proposer, critic, synthesizer"
    - "ConsensusAgnoTriad uses _get_model_for_role to get models for peer_1, peer_2, peer_3"
    - "All AgnoTriad subclasses pass model_selector to super().__init__ instead of single model"
    - "create_agno_triad successfully instantiates all three subclasses"
  artifacts:
    - path: "hfs/agno/teams/hierarchical.py"
      provides: "HierarchicalAgnoTriad with ModelSelector integration"
      contains: "_get_model_for_role"
    - path: "hfs/agno/teams/dialectic.py"
      provides: "DialecticAgnoTriad with ModelSelector integration"
      contains: "_get_model_for_role"
    - path: "hfs/agno/teams/consensus.py"
      provides: "ConsensusAgnoTriad with ModelSelector integration"
      contains: "_get_model_for_role"
    - path: "tests/unit/test_agno_triad_subclasses.py"
      provides: "Tests for subclass ModelSelector integration"
      min_lines: 80
  key_links:
    - from: "hfs/agno/teams/hierarchical.py"
      to: "hfs/agno/teams/base.py"
      via: "super().__init__ with model_selector"
      pattern: "super\\(\\).__init__.*model_selector"
    - from: "hfs/agno/teams/hierarchical.py"
      to: "_get_model_for_role"
      via: "method call in _create_agents"
      pattern: "self._get_model_for_role"
---

<objective>
Update AgnoTriad subclasses to use ModelSelector for role-specific models

Purpose: Plan 05-04 established the ModelSelector infrastructure in the base class. This plan updates all three subclasses (HierarchicalAgnoTriad, DialecticAgnoTriad, ConsensusAgnoTriad) to use the new API, calling _get_model_for_role() to get appropriate models for each agent role.

Output:
- All three AgnoTriad subclasses use ModelSelector via _get_model_for_role()
- Each agent in a triad gets a model matched to its role (orchestrator, worker, etc.)
- create_agno_triad() successfully instantiates all subclasses
- Tests verify the wiring is complete
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-model-tiers/05-04-SUMMARY.md

# Key source files to modify
@hfs/agno/teams/base.py
@hfs/agno/teams/hierarchical.py
@hfs/agno/teams/dialectic.py
@hfs/agno/teams/consensus.py
@hfs/core/model_selector.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update HierarchicalAgnoTriad for ModelSelector</name>
  <files>hfs/agno/teams/hierarchical.py</files>
  <action>
Update HierarchicalAgnoTriad to use the new ModelSelector-based API:

1. **Add imports for new types:**
   ```python
   from typing import Optional
   from hfs.core.model_selector import ModelSelector
   from hfs.core.escalation_tracker import EscalationTracker
   ```

2. **Update __init__ signature:**
   Change from:
   ```python
   def __init__(
       self,
       config: TriadConfig,
       model: Model,
       spec: "Any",
   ) -> None:
   ```
   To:
   ```python
   def __init__(
       self,
       config: TriadConfig,
       model_selector: ModelSelector,
       spec: "Any",
       escalation_tracker: Optional[EscalationTracker] = None,
   ) -> None:
   ```

3. **Update __init__ body:**
   - Remove `self._temp_spec = spec` and `self._temp_config = config` (no longer needed)
   - Change super().__init__ call from:
     ```python
     super().__init__(config, model, spec)
     ```
     To:
     ```python
     super().__init__(
         config=config,
         model_selector=model_selector,
         spec=spec,
         escalation_tracker=escalation_tracker,
     )
     ```

4. **Update _create_agents to use _get_model_for_role:**
   Replace all `model=self.model` with role-specific model calls:

   For orchestrator:
   ```python
   orchestrator = Agent(
       name=f"{self.config.id}_orchestrator",
       role="Task coordinator and integrator",
       model=self._get_model_for_role("orchestrator"),
       # ... rest unchanged
   )
   ```

   For worker_a:
   ```python
   worker_a = Agent(
       name=f"{self.config.id}_worker_a",
       role="Subtask executor",
       model=self._get_model_for_role("worker_a"),
       # ... rest unchanged
   )
   ```

   For worker_b:
   ```python
   worker_b = Agent(
       name=f"{self.config.id}_worker_b",
       role="Subtask executor",
       model=self._get_model_for_role("worker_b"),
       # ... rest unchanged
   )
   ```

5. **Update _create_team to use _get_model_for_role for team model:**
   The Team also needs a model. Use the orchestrator's model:
   ```python
   return Team(
       name=f"triad_{self.config.id}",
       model=self._get_model_for_role("orchestrator"),  # Team uses orchestrator's model
       # ... rest unchanged
   )
   ```

6. **Update docstring** to document new parameters.
  </action>
  <verify>
- `grep "_get_model_for_role" hfs/agno/teams/hierarchical.py` shows method calls
- `grep "model_selector: ModelSelector" hfs/agno/teams/hierarchical.py` shows new parameter
- `grep "escalation_tracker" hfs/agno/teams/hierarchical.py` shows tracker parameter
- No `self.model` references remain (except in comments)
  </verify>
  <done>
HierarchicalAgnoTriad uses ModelSelector via _get_model_for_role for orchestrator, worker_a, worker_b
  </done>
</task>

<task type="auto">
  <name>Task 2: Update DialecticAgnoTriad for ModelSelector</name>
  <files>hfs/agno/teams/dialectic.py</files>
  <action>
Update DialecticAgnoTriad with the same pattern as HierarchicalAgnoTriad:

1. **Add imports:**
   ```python
   from typing import Optional
   from hfs.core.model_selector import ModelSelector
   from hfs.core.escalation_tracker import EscalationTracker
   ```

2. **Update __init__ signature:**
   ```python
   def __init__(
       self,
       config: TriadConfig,
       model_selector: ModelSelector,
       spec: "Any",
       escalation_tracker: Optional[EscalationTracker] = None,
   ) -> None:
   ```

3. **Update super().__init__ call:**
   ```python
   super().__init__(
       config=config,
       model_selector=model_selector,
       spec=spec,
       escalation_tracker=escalation_tracker,
   )
   ```

4. **Update _create_agents for dialectic roles:**
   - proposer: `model=self._get_model_for_role("proposer")`
   - critic: `model=self._get_model_for_role("critic")`
   - synthesizer: `model=self._get_model_for_role("synthesizer")`

5. **Update _create_team:**
   - Use synthesizer's model for the team: `model=self._get_model_for_role("synthesizer")`
  </action>
  <verify>
- `grep "_get_model_for_role" hfs/agno/teams/dialectic.py` shows method calls
- `grep "model_selector: ModelSelector" hfs/agno/teams/dialectic.py` shows new parameter
- Roles: proposer, critic, synthesizer each get their own model
  </verify>
  <done>
DialecticAgnoTriad uses ModelSelector via _get_model_for_role for proposer, critic, synthesizer
  </done>
</task>

<task type="auto">
  <name>Task 3: Update ConsensusAgnoTriad for ModelSelector</name>
  <files>hfs/agno/teams/consensus.py</files>
  <action>
Update ConsensusAgnoTriad with the same pattern:

1. **Add imports:**
   ```python
   from typing import Optional
   from hfs.core.model_selector import ModelSelector
   from hfs.core.escalation_tracker import EscalationTracker
   ```

2. **Update __init__ signature:**
   ```python
   def __init__(
       self,
       config: TriadConfig,
       model_selector: ModelSelector,
       spec: "Any",
       escalation_tracker: Optional[EscalationTracker] = None,
   ) -> None:
   ```

3. **Update super().__init__ call:**
   ```python
   super().__init__(
       config=config,
       model_selector=model_selector,
       spec=spec,
       escalation_tracker=escalation_tracker,
   )
   ```

4. **Update _create_agents for consensus roles:**
   - peer_1: `model=self._get_model_for_role("peer_1")`
   - peer_2: `model=self._get_model_for_role("peer_2")`
   - peer_3: `model=self._get_model_for_role("peer_3")`

5. **Update _create_team:**
   - Use peer_1's model for the team: `model=self._get_model_for_role("peer_1")`
  </action>
  <verify>
- `grep "_get_model_for_role" hfs/agno/teams/consensus.py` shows method calls
- `grep "model_selector: ModelSelector" hfs/agno/teams/consensus.py` shows new parameter
- Roles: peer_1, peer_2, peer_3 each get their own model
  </verify>
  <done>
ConsensusAgnoTriad uses ModelSelector via _get_model_for_role for peer_1, peer_2, peer_3
  </done>
</task>

<task type="auto">
  <name>Task 4: Create tests for subclass ModelSelector integration</name>
  <files>tests/unit/test_agno_triad_subclasses.py</files>
  <action>
Create tests verifying the subclass integration works end-to-end:

```python
"""Tests for AgnoTriad subclass ModelSelector integration.

Verifies that HierarchicalAgnoTriad, DialecticAgnoTriad, and ConsensusAgnoTriad
properly use _get_model_for_role to get role-specific models.
"""

import pytest
import inspect
from pathlib import Path
from unittest.mock import Mock, MagicMock, patch
import tempfile
import shutil

from hfs.core.model_tiers import ModelTiersConfig, TierConfig
from hfs.core.model_selector import ModelSelector
from hfs.core.escalation_tracker import EscalationTracker
from hfs.core.triad import TriadConfig, TriadPreset
from hfs.agno.teams.hierarchical import HierarchicalAgnoTriad
from hfs.agno.teams.dialectic import DialecticAgnoTriad
from hfs.agno.teams.consensus import ConsensusAgnoTriad
from hfs.presets.triad_factory import create_agno_triad


# ============================================================
# Test fixtures
# ============================================================

@pytest.fixture
def sample_tiers_config():
    """Create a minimal ModelTiersConfig for testing."""
    return ModelTiersConfig(
        tiers={
            "reasoning": TierConfig(
                description="High capability",
                providers={"cerebras": "llama-3.3-70b"}
            ),
            "general": TierConfig(
                description="Balanced",
                providers={"cerebras": "llama-3.1-8b"}
            ),
            "fast": TierConfig(
                description="Quick",
                providers={"cerebras": "llama-3.1-8b"}
            ),
        },
        role_defaults={
            "orchestrator": "reasoning",
            "worker_a": "general",
            "worker_b": "general",
            "proposer": "general",
            "critic": "general",
            "synthesizer": "reasoning",
            "peer_1": "general",
            "peer_2": "general",
            "peer_3": "general",
        },
        phase_overrides={},
        escalation_state={},
    )


@pytest.fixture
def mock_provider_manager():
    """Create a mock ProviderManager that returns mock models."""
    manager = Mock()
    manager.available_providers = ["cerebras"]
    # Return a unique mock for each call so we can track which model goes where
    manager.get_model = Mock(side_effect=lambda provider, model_id: Mock(name=f"{provider}:{model_id}"))
    return manager


@pytest.fixture
def model_selector(sample_tiers_config, mock_provider_manager):
    """Create ModelSelector with test config."""
    return ModelSelector(sample_tiers_config, mock_provider_manager)


@pytest.fixture
def sample_config():
    """Create a sample TriadConfig for testing."""
    return TriadConfig(
        id="test_triad",
        preset=TriadPreset.HIERARCHICAL,
        scope_primary=["test"],
        scope_reach=[],
        budget_tokens=1000,
        budget_tool_calls=10,
        budget_time_ms=5000,
        objectives=["test"],
    )


@pytest.fixture
def mock_spec():
    """Create a mock Spec object."""
    return Mock()


# ============================================================
# Signature tests
# ============================================================

class TestHierarchicalSignature:
    """Test HierarchicalAgnoTriad has correct signature."""

    def test_init_accepts_model_selector(self):
        """HierarchicalAgnoTriad.__init__ should accept model_selector."""
        sig = inspect.signature(HierarchicalAgnoTriad.__init__)
        params = list(sig.parameters.keys())
        assert "model_selector" in params

    def test_init_accepts_escalation_tracker(self):
        """HierarchicalAgnoTriad.__init__ should accept escalation_tracker."""
        sig = inspect.signature(HierarchicalAgnoTriad.__init__)
        params = list(sig.parameters.keys())
        assert "escalation_tracker" in params


class TestDialecticSignature:
    """Test DialecticAgnoTriad has correct signature."""

    def test_init_accepts_model_selector(self):
        """DialecticAgnoTriad.__init__ should accept model_selector."""
        sig = inspect.signature(DialecticAgnoTriad.__init__)
        params = list(sig.parameters.keys())
        assert "model_selector" in params

    def test_init_accepts_escalation_tracker(self):
        """DialecticAgnoTriad.__init__ should accept escalation_tracker."""
        sig = inspect.signature(DialecticAgnoTriad.__init__)
        params = list(sig.parameters.keys())
        assert "escalation_tracker" in params


class TestConsensusSignature:
    """Test ConsensusAgnoTriad has correct signature."""

    def test_init_accepts_model_selector(self):
        """ConsensusAgnoTriad.__init__ should accept model_selector."""
        sig = inspect.signature(ConsensusAgnoTriad.__init__)
        params = list(sig.parameters.keys())
        assert "model_selector" in params

    def test_init_accepts_escalation_tracker(self):
        """ConsensusAgnoTriad.__init__ should accept escalation_tracker."""
        sig = inspect.signature(ConsensusAgnoTriad.__init__)
        params = list(sig.parameters.keys())
        assert "escalation_tracker" in params


# ============================================================
# Factory tests
# ============================================================

class TestCreateAgnoTriad:
    """Test that create_agno_triad works with all presets."""

    @pytest.mark.parametrize("preset,expected_class", [
        (TriadPreset.HIERARCHICAL, HierarchicalAgnoTriad),
        (TriadPreset.DIALECTIC, DialecticAgnoTriad),
        (TriadPreset.CONSENSUS, ConsensusAgnoTriad),
    ])
    def test_create_agno_triad_returns_correct_class(
        self,
        preset,
        expected_class,
        model_selector,
        mock_spec,
    ):
        """create_agno_triad should return the correct subclass."""
        config = TriadConfig(
            id="test_triad",
            preset=preset,
            scope_primary=["test"],
            scope_reach=[],
            budget_tokens=1000,
            budget_tool_calls=10,
            budget_time_ms=5000,
            objectives=["test"],
        )

        triad = create_agno_triad(
            config=config,
            model_selector=model_selector,
            spec=mock_spec,
        )

        assert isinstance(triad, expected_class)


# ============================================================
# Role model assignment tests
# ============================================================

class TestHierarchicalRoleModels:
    """Test that HierarchicalAgnoTriad assigns correct models to roles."""

    def test_agents_get_different_models(self, model_selector, sample_config, mock_spec, mock_provider_manager):
        """Each agent should get model via _get_model_for_role."""
        triad = HierarchicalAgnoTriad(
            config=sample_config,
            model_selector=model_selector,
            spec=mock_spec,
        )

        # Verify get_model was called for each role
        calls = mock_provider_manager.get_model.call_args_list
        assert len(calls) >= 3, "Should call get_model for at least 3 agents"


class TestDialecticRoleModels:
    """Test that DialecticAgnoTriad assigns correct models to roles."""

    def test_agents_get_different_models(self, model_selector, mock_spec, mock_provider_manager):
        """Each agent should get model via _get_model_for_role."""
        config = TriadConfig(
            id="test_triad",
            preset=TriadPreset.DIALECTIC,
            scope_primary=["test"],
            scope_reach=[],
            budget_tokens=1000,
            budget_tool_calls=10,
            budget_time_ms=5000,
            objectives=["test"],
        )

        triad = DialecticAgnoTriad(
            config=config,
            model_selector=model_selector,
            spec=mock_spec,
        )

        # Verify get_model was called for each role
        calls = mock_provider_manager.get_model.call_args_list
        assert len(calls) >= 3, "Should call get_model for at least 3 agents"


class TestConsensusRoleModels:
    """Test that ConsensusAgnoTriad assigns correct models to roles."""

    def test_agents_get_different_models(self, model_selector, mock_spec, mock_provider_manager):
        """Each agent should get model via _get_model_for_role."""
        config = TriadConfig(
            id="test_triad",
            preset=TriadPreset.CONSENSUS,
            scope_primary=["test"],
            scope_reach=[],
            budget_tokens=1000,
            budget_tool_calls=10,
            budget_time_ms=5000,
            objectives=["test"],
        )

        triad = ConsensusAgnoTriad(
            config=config,
            model_selector=model_selector,
            spec=mock_spec,
        )

        # Verify get_model was called for each role
        calls = mock_provider_manager.get_model.call_args_list
        assert len(calls) >= 3, "Should call get_model for at least 3 agents"
```

Run tests: `pytest tests/unit/test_agno_triad_subclasses.py -v`
  </action>
  <verify>
- `pytest tests/unit/test_agno_triad_subclasses.py -v` - all tests pass
- Test file exists and has at least 80 lines
- Tests cover all three subclasses
- Tests verify create_agno_triad works
  </verify>
  <done>
Tests verify all AgnoTriad subclasses properly use ModelSelector for role-specific models
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **All subclasses updated:**
   ```bash
   grep "_get_model_for_role" hfs/agno/teams/hierarchical.py
   grep "_get_model_for_role" hfs/agno/teams/dialectic.py
   grep "_get_model_for_role" hfs/agno/teams/consensus.py
   ```

2. **No legacy model parameter:**
   ```bash
   # These should NOT find `model: Model` in __init__ signatures
   grep "def __init__" hfs/agno/teams/hierarchical.py -A 5 | grep -v model_selector
   ```

3. **All tests pass:**
   ```bash
   pytest tests/unit/test_agno_triad_subclasses.py -v
   pytest tests/unit/test_model_tier*.py -v
   ```

4. **Factory instantiation works:**
   ```bash
   python -c "
   from hfs.presets.triad_factory import create_agno_triad
   from hfs.core.triad import TriadConfig, TriadPreset
   from unittest.mock import Mock

   config = TriadConfig(id='test', preset=TriadPreset.HIERARCHICAL, scope_primary=['test'], scope_reach=[], budget_tokens=1000, budget_tool_calls=10, budget_time_ms=5000, objectives=['test'])

   mock_selector = Mock()
   mock_selector.get_model = Mock(return_value=Mock())
   mock_spec = Mock()

   triad = create_agno_triad(config, mock_selector, mock_spec)
   print(f'Created: {type(triad).__name__}')
   "
   ```
</verification>

<success_criteria>
- HierarchicalAgnoTriad uses _get_model_for_role for orchestrator, worker_a, worker_b
- DialecticAgnoTriad uses _get_model_for_role for proposer, critic, synthesizer
- ConsensusAgnoTriad uses _get_model_for_role for peer_1, peer_2, peer_3
- All subclasses pass model_selector (not model) to super().__init__
- All subclasses accept optional escalation_tracker parameter
- create_agno_triad successfully instantiates all three subclass types
- Tests verify the wiring is complete
- Existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/05-model-tiers/05-05-SUMMARY.md`
</output>
