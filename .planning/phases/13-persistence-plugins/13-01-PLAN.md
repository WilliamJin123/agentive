---
phase: 13-persistence-plugins
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - hfs/persistence/__init__.py
  - hfs/persistence/engine.py
  - hfs/persistence/models.py
  - hfs/persistence/repository.py
  - hfs/tui/screens/chat.py
  - hfs/tui/app.py
  - hfs/pyproject.toml
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Sessions persist to SQLite database at ~/.hfs/sessions.db"
    - "User can list previous sessions with /sessions command"
    - "User can resume a previous session by ID"
    - "User can rename sessions"
    - "Messages auto-save after each exchange"
  artifacts:
    - path: "hfs/persistence/engine.py"
      provides: "Async SQLite engine with WAL mode"
      exports: ["create_db_engine", "get_session_factory"]
    - path: "hfs/persistence/models.py"
      provides: "SQLAlchemy ORM models"
      exports: ["Base", "SessionModel", "MessageModel"]
    - path: "hfs/persistence/repository.py"
      provides: "CRUD operations for sessions"
      exports: ["SessionRepository"]
  key_links:
    - from: "hfs/tui/screens/chat.py"
      to: "hfs/persistence/repository.py"
      via: "SessionRepository calls on message send"
      pattern: "await.*session_repo"
    - from: "hfs/persistence/engine.py"
      to: "aiosqlite"
      via: "SQLAlchemy async engine"
      pattern: "sqlite\\+aiosqlite"
---

<objective>
Implement session persistence using SQLAlchemy 2.x with AsyncSession and SQLite.

Purpose: Enable users to save, list, resume, and rename chat sessions. Sessions auto-save after each message exchange, with auto-generated names from first message + timestamp.

Output: Working /sessions, resume, and rename commands with database persistence.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-persistence-plugins/13-RESEARCH.md

# Existing code to integrate with
@hfs/tui/screens/chat.py
@hfs/tui/app.py
@hfs/user_config/loader.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create persistence module with SQLAlchemy models and engine</name>
  <files>
    hfs/persistence/__init__.py
    hfs/persistence/engine.py
    hfs/persistence/models.py
    hfs/pyproject.toml
  </files>
  <action>
Create hfs/persistence/ module with:

1. Add dependencies to pyproject.toml:
   - sqlalchemy[asyncio]>=2.0
   - aiosqlite>=0.20

2. Create hfs/persistence/engine.py:
   - create_db_engine(db_path: Path | None = None) -> AsyncEngine
     - Default path: ~/.hfs/sessions.db
     - Create parent directories if needed
     - Enable WAL mode via PRAGMA journal_mode=WAL
     - Create tables via Base.metadata.create_all
   - get_session_factory(engine: AsyncEngine) -> async_sessionmaker[AsyncSession]
     - Use expire_on_commit=False to avoid async lazy loading issues

3. Create hfs/persistence/models.py with SQLAlchemy 2.x style:
   - Base(AsyncAttrs, DeclarativeBase) - base class
   - SessionModel:
     - id: int (primary key)
     - name: str (255 chars) - auto-generated from first message
     - created_at: datetime
     - updated_at: datetime | None
     - messages: relationship to MessageModel (lazy="selectin")
   - MessageModel:
     - id: int (primary key)
     - session_id: int (foreign key)
     - role: str (50 chars) - "user", "assistant", "system"
     - content: str (Text)
     - created_at: datetime
     - session: relationship back to SessionModel

4. Create hfs/persistence/__init__.py exporting:
   - Base, SessionModel, MessageModel
   - create_db_engine, get_session_factory

Use SQLAlchemy 2.x patterns from RESEARCH.md: Mapped[], mapped_column(), relationship().
  </action>
  <verify>
    python -c "from hfs.persistence import Base, SessionModel, MessageModel, create_db_engine"
  </verify>
  <done>
    Persistence module exists with ORM models and async engine factory. Import succeeds without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SessionRepository with CRUD operations</name>
  <files>
    hfs/persistence/repository.py
    hfs/persistence/__init__.py
  </files>
  <action>
Create hfs/persistence/repository.py with SessionRepository class:

class SessionRepository:
    def __init__(self, session_factory: async_sessionmaker[AsyncSession])

    Methods:
    1. async def create(self, name: str | None = None) -> SessionModel
       - If name is None, use placeholder (updated on first message)
       - Set created_at to utcnow()

    2. async def get(self, session_id: int) -> SessionModel | None
       - Load session with messages via selectinload

    3. async def list_recent(self, limit: int = 20) -> list[SessionModel]
       - Order by created_at DESC
       - Include message count as computed property

    4. async def rename(self, session_id: int, new_name: str) -> SessionModel | None
       - Update name and updated_at

    5. async def add_message(self, session_id: int, role: str, content: str) -> MessageModel
       - Create message, update session.updated_at
       - If this is first user message and session name is placeholder, generate name:
         - First 30 chars of message + " - " + timestamp (YYYY-MM-DD_HH-MM)

    6. async def delete(self, session_id: int) -> bool
       - Delete session and cascade to messages

Use async context manager pattern from RESEARCH.md:
    async with self._session_factory() as session:
        async with session.begin():
            # operations

Update hfs/persistence/__init__.py to export SessionRepository.
  </action>
  <verify>
    python -c "from hfs.persistence import SessionRepository; print('Repository OK')"
  </verify>
  <done>
    SessionRepository class exists with all CRUD methods. Follows async context manager pattern.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire persistence to TUI with slash commands</name>
  <files>
    hfs/tui/app.py
    hfs/tui/screens/chat.py
  </files>
  <action>
1. Update hfs/tui/app.py:
   - Add _db_engine: AsyncEngine | None = None
   - Add _session_factory: async_sessionmaker | None = None
   - Add _session_repo: SessionRepository | None = None
   - Add _current_session_id: int | None = None

   - Add async def initialize_persistence(self) -> None:
     - Create engine via create_db_engine()
     - Create session factory via get_session_factory(engine)
     - Create SessionRepository with factory

   - Add get_session_repo(self) -> SessionRepository | None
   - Add get_current_session_id(self) -> int | None
   - Add set_current_session_id(self, session_id: int) -> None

   - Update on_mount to call initialize_persistence()

2. Update hfs/tui/screens/chat.py:

   Add to SLASH_COMMANDS:
     "/sessions": "handle_sessions"
     "/resume": "handle_resume"
     "/rename": "handle_rename"

   Add async def handle_sessions(self, text: str) -> None:
     - Get session_repo from app
     - If None, show "Persistence not available"
     - Call list_recent(20)
     - Format as table: | ID | Name | Messages | Created |
     - Highlight current session with (current)

   Add async def handle_resume(self, text: str) -> None:
     - Parse session ID from "/resume <id>"
     - Load session via repo.get(id)
     - If not found, show error
     - Clear current messages
     - Load all messages into MessageList
     - Set app.set_current_session_id(id)
     - Show "Resumed session: {name}"

   Add async def handle_rename(self, text: str) -> None:
     - Parse "/rename <new_name>" (uses current session)
     - Or "/rename <id> <new_name>" (specific session)
     - Call repo.rename()
     - Show "Session renamed to: {new_name}"

   Update send_message to auto-save:
     - After adding user message, call repo.add_message(session_id, "user", text)
     - After streaming completes, call repo.add_message(session_id, "assistant", full_response)
     - Create new session if current_session_id is None

3. Update ChatScreen.on_mount:
   - Create new session if none exists (lazy initialization)
  </action>
  <verify>
    python -c "from hfs.tui.screens import ChatScreen; print('ChatScreen imports OK')"
    # Manual test: hfs, then /sessions should show empty list or sessions
  </verify>
  <done>
    /sessions lists saved sessions with ID, name, message count, date.
    /resume loads a previous session's messages.
    /rename changes session name.
    Messages auto-save after each exchange.
  </done>
</task>

</tasks>

<verification>
1. Run: pip install -e . (to install new dependencies)
2. Run: python -c "from hfs.persistence import *" (imports work)
3. Run: hfs (TUI starts without errors)
4. In TUI: /sessions (shows empty list or existing sessions)
5. Send a message, then /sessions (new session appears with auto-generated name)
6. Exit and restart hfs, /sessions (session persists)
7. /resume <id> (loads previous messages)
8. /rename "New Name" (changes current session name)
</verification>

<success_criteria>
- SQLite database created at ~/.hfs/sessions.db
- Sessions and messages persist across restarts
- /sessions shows session list with ID, name, message count, date
- /resume restores conversation history
- /rename updates session name
- Auto-save works after each message exchange
</success_criteria>

<output>
After completion, create `.planning/phases/13-persistence-plugins/13-01-SUMMARY.md`
</output>
