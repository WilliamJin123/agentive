---
phase: 13-persistence-plugins
plan: 03
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - hfs/export/__init__.py
  - hfs/export/markdown.py
  - hfs/export/json_export.py
  - hfs/export/json_import.py
  - hfs/export/migration.py
  - hfs/tui/screens/chat.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User can export conversation to markdown with full trace"
    - "User can export conversation to JSON with schema version"
    - "User can import conversation from JSON file"
    - "Schema mismatches handled via automatic migration"
    - "Exports saved to ~/.hfs/exports/ by default"
  artifacts:
    - path: "hfs/export/markdown.py"
      provides: "Markdown export with messages, agents, tokens, timing"
      exports: ["export_to_markdown"]
    - path: "hfs/export/json_export.py"
      provides: "Versioned JSON export"
      exports: ["export_to_json", "EXPORT_SCHEMA_VERSION"]
    - path: "hfs/export/json_import.py"
      provides: "JSON import with migration support"
      exports: ["import_from_json"]
    - path: "hfs/export/migration.py"
      provides: "Schema version migration functions"
      exports: ["migrate_export"]
  key_links:
    - from: "hfs/tui/screens/chat.py"
      to: "hfs/export/markdown.py"
      via: "/export md command"
      pattern: "export_to_markdown"
    - from: "hfs/export/json_import.py"
      to: "hfs/export/migration.py"
      via: "Version check and migration"
      pattern: "migrate_export"
---

<objective>
Implement export/import functionality for conversations.

Purpose: Enable users to export conversations to markdown (for sharing/documentation) and JSON (for backup/transfer), and import from JSON files. Markdown includes full trace with agents, tokens, timing. JSON uses versioned schema for forward compatibility.

Output: Working /export and /import commands with migration support.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-persistence-plugins/13-RESEARCH.md
@.planning/phases/13-persistence-plugins/13-01-SUMMARY.md

# Existing code patterns
@hfs/state/models.py
@hfs/persistence/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create export module with markdown and JSON export</name>
  <files>
    hfs/export/__init__.py
    hfs/export/markdown.py
    hfs/export/json_export.py
  </files>
  <action>
Create hfs/export/ module:

1. Create hfs/export/markdown.py:

   def export_to_markdown(
       session_name: str,
       messages: list[dict],  # [{role, content, created_at}, ...]
       run_snapshot: RunSnapshot | None = None,
   ) -> str:
       """Export conversation to markdown with full trace.

       Format:
       # HFS Session: {session_name}

       **Exported:** {timestamp}
       **Messages:** {count}

       {If run_snapshot exists:}
       **Tokens:** {total}
       **Duration:** {ms}ms

       ## Agent Activity

       ### Triad: {id} ({preset})
       - {role}: {status}
       ...

       ## Conversation

       ### User
       {content}

       ### Assistant
       {content}
       ...
       """
       Return formatted markdown string.

2. Create hfs/export/json_export.py:

   EXPORT_SCHEMA_VERSION = "1.0.0"

   class ExportMetadata(BaseModel):
       schema_version: str = EXPORT_SCHEMA_VERSION
       exported_at: datetime
       hfs_version: str
       session_name: str

   class SessionExport(BaseModel):
       metadata: ExportMetadata
       messages: list[dict[str, Any]]
       checkpoints: list[dict[str, Any]] | None = None
       run_snapshot: dict[str, Any] | None = None

   def export_to_json(
       session_name: str,
       messages: list[dict],
       run_snapshot: RunSnapshot | None = None,
       checkpoints: list[dict] | None = None,
   ) -> str:
       """Export session to JSON with schema version.

       Returns pretty-printed JSON (indent=2).
       """

3. Create hfs/export/__init__.py:
   Export: export_to_markdown, export_to_json, EXPORT_SCHEMA_VERSION
  </action>
  <verify>
    python -c "from hfs.export import export_to_markdown, export_to_json, EXPORT_SCHEMA_VERSION; print(f'Schema v{EXPORT_SCHEMA_VERSION}')"
  </verify>
  <done>
    export_to_markdown() creates formatted markdown with full trace.
    export_to_json() creates versioned JSON with metadata, messages, optional checkpoints/snapshot.
    EXPORT_SCHEMA_VERSION is "1.0.0".
  </done>
</task>

<task type="auto">
  <name>Task 2: Create JSON import with migration support</name>
  <files>
    hfs/export/json_import.py
    hfs/export/migration.py
    hfs/export/__init__.py
  </files>
  <action>
1. Create hfs/export/migration.py:

   CURRENT_VERSION = "1.0.0"

   def migrate_export(data: dict) -> dict:
       """Migrate export data to current schema version.

       Args:
           data: Raw JSON data from import file

       Returns:
           Migrated data compatible with current version

       Raises:
           ValueError: If migration not possible (future version)
       """
       version = data.get("metadata", {}).get("schema_version", "0.0.0")

       if version == CURRENT_VERSION:
           return data  # No migration needed

       # Future: Add migration functions as schema evolves
       # if version == "0.9.0":
       #     data = migrate_0_9_to_1_0(data)
       #     version = "1.0.0"

       if version > CURRENT_VERSION:
           raise ValueError(
               f"Export version {version} is newer than supported {CURRENT_VERSION}. "
               "Please upgrade HFS."
           )

       # Handle very old versions without metadata
       if "metadata" not in data:
           data = {
               "metadata": {
                   "schema_version": CURRENT_VERSION,
                   "exported_at": datetime.utcnow().isoformat(),
                   "hfs_version": "unknown",
                   "session_name": "Imported Session",
               },
               "messages": data.get("messages", []),
           }

       return data

2. Create hfs/export/json_import.py:

   from .migration import migrate_export, CURRENT_VERSION

   class ImportResult(BaseModel):
       session_name: str
       messages: list[dict[str, Any]]
       migrated: bool  # True if migration was applied
       original_version: str

   def import_from_json(json_content: str) -> ImportResult:
       """Import conversation from JSON file.

       Handles schema migration automatically.

       Args:
           json_content: Raw JSON string from file

       Returns:
           ImportResult with session_name, messages, migration info

       Raises:
           ValueError: If JSON invalid or migration fails
           json.JSONDecodeError: If not valid JSON
       """
       data = json.loads(json_content)
       original_version = data.get("metadata", {}).get("schema_version", "0.0.0")

       # Migrate to current version
       migrated_data = migrate_export(data)
       was_migrated = original_version != CURRENT_VERSION

       return ImportResult(
           session_name=migrated_data["metadata"]["session_name"],
           messages=migrated_data["messages"],
           migrated=was_migrated,
           original_version=original_version,
       )

3. Update hfs/export/__init__.py:
   Export: import_from_json, migrate_export, ImportResult
  </action>
  <verify>
    python -c "from hfs.export import import_from_json, migrate_export; print('Import OK')"
  </verify>
  <done>
    import_from_json() parses JSON, applies migration, returns ImportResult.
    migrate_export() handles version differences silently.
    Graceful handling of old/missing metadata.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire export/import to TUI with slash commands</name>
  <files>
    hfs/tui/screens/chat.py
  </files>
  <action>
Update hfs/tui/screens/chat.py:

Add to SLASH_COMMANDS:
    "/export": "handle_export"
    "/import": "handle_import"

Add async def handle_export(self, text: str) -> None:
    """Handle /export command.

    Subcommands:
        /export md [filename] - Export to markdown
        /export json [filename] - Export to JSON
        /export - Show usage
    """
    message_list = self.query_one("#messages", MessageList)
    parts = text.strip().split(maxsplit=2)

    if len(parts) < 2:
        await message_list.add_message(
            "**Usage:**\n"
            "- `/export md [filename]` - Export to markdown\n"
            "- `/export json [filename]` - Export to JSON\n\n"
            "Default location: `~/.hfs/exports/`",
            is_system=True,
        )
        return

    format_type = parts[1].lower()
    if format_type not in ("md", "json"):
        await message_list.add_message(
            f"Unknown format: `{format_type}`. Use `md` or `json`.",
            is_system=True,
        )
        return

    # Get session info
    session_repo = self.app.get_session_repo()
    session_id = self.app.get_current_session_id()
    if not session_repo or not session_id:
        await message_list.add_message(
            "No active session to export.",
            is_system=True,
        )
        return

    session = await session_repo.get(session_id)
    if not session:
        await message_list.add_message("Session not found.", is_system=True)
        return

    # Prepare messages for export
    messages = [
        {"role": m.role, "content": m.content, "created_at": m.created_at.isoformat()}
        for m in session.messages
    ]

    # Generate filename
    exports_dir = Path.home() / ".hfs" / "exports"
    exports_dir.mkdir(parents=True, exist_ok=True)

    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    safe_name = "".join(c if c.isalnum() or c in "- " else "_" for c in session.name[:30])

    if len(parts) >= 3:
        filename = parts[2]
    else:
        ext = "md" if format_type == "md" else "json"
        filename = f"{safe_name}_{timestamp}.{ext}"

    filepath = exports_dir / filename

    # Export
    from hfs.export import export_to_markdown, export_to_json

    if format_type == "md":
        content = export_to_markdown(session.name, messages)
    else:
        # Get checkpoint info if available
        checkpoint_repo = self.app.get_checkpoint_repo()
        checkpoints = None
        if checkpoint_repo:
            cp_list = await checkpoint_repo.list_for_session(session_id)
            checkpoints = [
                {"trigger": c.trigger_event, "message_index": c.message_index, "created_at": c.created_at.isoformat()}
                for c in cp_list
            ]
        content = export_to_json(session.name, messages, checkpoints=checkpoints)

    filepath.write_text(content, encoding="utf-8")

    await message_list.add_message(
        f"**Exported successfully**\n\n"
        f"Format: `{format_type}`\n"
        f"File: `{filepath}`\n"
        f"Messages: {len(messages)}",
        is_system=True,
    )

Add async def handle_import(self, text: str) -> None:
    """Handle /import command.

    Usage: /import <filepath>
    """
    message_list = self.query_one("#messages", MessageList)
    parts = text.strip().split(maxsplit=1)

    if len(parts) < 2:
        await message_list.add_message(
            "**Usage:** `/import <filepath>`\n\n"
            "Import a previously exported JSON file.",
            is_system=True,
        )
        return

    filepath = Path(parts[1]).expanduser()
    if not filepath.exists():
        await message_list.add_message(
            f"File not found: `{filepath}`",
            is_system=True,
        )
        return

    try:
        json_content = filepath.read_text(encoding="utf-8")
        from hfs.export import import_from_json

        result = import_from_json(json_content)

        # Create new session with imported messages
        session_repo = self.app.get_session_repo()
        if not session_repo:
            await message_list.add_message("Persistence not available.", is_system=True)
            return

        # Create session
        new_session = await session_repo.create(name=f"{result.session_name} (imported)")

        # Add messages
        for msg in result.messages:
            await session_repo.add_message(
                new_session.id,
                msg["role"],
                msg["content"],
            )

        # Set as current session and load messages
        self.app.set_current_session_id(new_session.id)
        await message_list.clear_messages()

        for msg in result.messages:
            is_user = msg["role"] == "user"
            is_system = msg["role"] == "system"
            await message_list.add_message(msg["content"], is_user=is_user, is_system=is_system)

        migration_note = ""
        if result.migrated:
            migration_note = f"\n*Migrated from schema v{result.original_version}*"

        await message_list.add_message(
            f"**Imported successfully**\n\n"
            f"Session: `{new_session.name}`\n"
            f"Messages: {len(result.messages)}{migration_note}",
            is_system=True,
        )

    except json.JSONDecodeError as e:
        await message_list.add_message(
            f"**Invalid JSON:** {e}",
            is_system=True,
        )
    except ValueError as e:
        await message_list.add_message(
            f"**Import failed:** {e}",
            is_system=True,
        )
    except Exception as e:
        await message_list.add_message(
            f"**Error:** {type(e).__name__}: {e}",
            is_system=True,
        )
  </action>
  <verify>
    python -c "from hfs.tui.screens import ChatScreen; print('ChatScreen OK')"
    # Manual: hfs, send messages, /export md, check ~/.hfs/exports/
  </verify>
  <done>
    /export md [filename] creates markdown with full trace.
    /export json [filename] creates versioned JSON.
    /import <filepath> loads JSON, creates new session, shows migration info if applicable.
    Default export location is ~/.hfs/exports/.
  </done>
</task>

</tasks>

<verification>
1. Run: python -c "from hfs.export import *" (imports work)
2. Run: hfs
3. Send a few messages
4. /export md (creates markdown in ~/.hfs/exports/)
5. Check file content (includes session name, messages, timestamp)
6. /export json (creates JSON with metadata.schema_version)
7. Check file content (pretty-printed, has metadata block)
8. Exit, restart hfs
9. /import ~/.hfs/exports/<filename>.json (loads conversation)
10. Messages appear in chat
11. /sessions (shows new imported session)
</verification>

<success_criteria>
- /export md creates readable markdown with full trace
- /export json creates versioned JSON (schema_version: "1.0.0")
- /import loads JSON and creates new session
- Migration handles old/missing metadata gracefully
- Exports saved to ~/.hfs/exports/ by default
- Import shows migration note if schema was upgraded
</success_criteria>

<output>
After completion, create `.planning/phases/13-persistence-plugins/13-03-SUMMARY.md`
</output>
