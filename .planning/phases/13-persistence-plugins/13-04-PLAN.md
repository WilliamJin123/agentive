---
phase: 13-persistence-plugins
plan: 04
type: execute
wave: 3
depends_on: ["13-01", "13-02"]
files_modified:
  - hfs/plugins/__init__.py
  - hfs/plugins/discovery.py
  - hfs/plugins/hooks.py
  - hfs/plugins/manager.py
  - hfs/plugins/permissions.py
  - hfs/tui/app.py
  - hfs/tui/screens/chat.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Plugin discovery scans ~/.hfs/plugins/ directory"
    - "Plugins can register new slash commands"
    - "Plugins can hook into lifecycle events (on_start, on_message, on_run_complete)"
    - "Permission prompts appear when plugin first loads"
    - "Config can disable specific plugins"
  artifacts:
    - path: "hfs/plugins/discovery.py"
      provides: "Plugin discovery from ~/.hfs/plugins/"
      exports: ["discover_plugins", "PluginManifest"]
    - path: "hfs/plugins/hooks.py"
      provides: "Hook specifications"
      exports: ["HFSHookSpec"]
    - path: "hfs/plugins/manager.py"
      provides: "Plugin lifecycle management"
      exports: ["PluginManager"]
    - path: "hfs/plugins/permissions.py"
      provides: "Permission tracking and prompts"
      exports: ["PermissionManager", "PluginCapability"]
  key_links:
    - from: "hfs/tui/app.py"
      to: "hfs/plugins/manager.py"
      via: "Plugin initialization on startup"
      pattern: "plugin_manager\\.load_plugins"
    - from: "hfs/plugins/manager.py"
      to: "hfs/plugins/discovery.py"
      via: "Directory scanning"
      pattern: "discover_plugins"
    - from: "hfs/tui/screens/chat.py"
      to: "hfs/plugins/manager.py"
      via: "Hook calls on message/events"
      pattern: "plugin_manager\\.call_hook"
---

<objective>
Implement plugin system for extending HFS functionality.

Purpose: Enable users to extend HFS with custom commands, widgets, and lifecycle hooks. Plugins are discovered from ~/.hfs/plugins/, use a manifest.yaml for metadata, and require permission approval on first load.

Output: Working plugin discovery, registration, lifecycle hooks, and permission system.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-persistence-plugins/13-RESEARCH.md
@.planning/phases/13-persistence-plugins/13-01-SUMMARY.md
@.planning/phases/13-persistence-plugins/13-02-SUMMARY.md

# Existing code
@hfs/tui/app.py
@hfs/tui/screens/chat.py
@hfs/events/bus.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create plugin discovery and manifest system</name>
  <files>
    hfs/plugins/__init__.py
    hfs/plugins/discovery.py
    hfs/plugins/permissions.py
  </files>
  <action>
Create hfs/plugins/ module:

1. Create hfs/plugins/discovery.py:

   from pathlib import Path
   from pydantic import BaseModel
   import importlib.util
   import sys
   import yaml
   import logging

   logger = logging.getLogger(__name__)

   class PluginManifest(BaseModel):
       """Plugin manifest schema.

       Manifest file: ~/.hfs/plugins/<plugin_name>/manifest.yaml

       Example manifest.yaml:
           name: my-plugin
           version: 1.0.0
           description: Adds custom commands
           entry_point: __init__  # Module to import (default)
           capabilities:
             - commands
             - hooks
       """
       name: str
       version: str
       description: str | None = None
       entry_point: str = "__init__"  # Module filename without .py
       capabilities: list[str] = []  # commands, widgets, hooks

   class DiscoveredPlugin:
       """Container for discovered plugin data."""
       def __init__(self, manifest: PluginManifest, module: Any, path: Path):
           self.manifest = manifest
           self.module = module
           self.path = path

   def discover_plugins(
       plugins_dir: Path | None = None,
       disabled_plugins: list[str] | None = None,
   ) -> list[DiscoveredPlugin]:
       """Discover and load plugins from directory.

       Args:
           plugins_dir: Override for plugins directory (default: ~/.hfs/plugins)
           disabled_plugins: List of plugin names to skip

       Returns:
           List of successfully loaded plugins

       Plugin structure:
           ~/.hfs/plugins/
               my-plugin/
                   manifest.yaml
                   __init__.py
       """
       if plugins_dir is None:
           plugins_dir = Path.home() / ".hfs" / "plugins"

       if disabled_plugins is None:
           disabled_plugins = []

       if not plugins_dir.exists():
           return []

       plugins = []

       for plugin_path in plugins_dir.iterdir():
           if not plugin_path.is_dir():
               continue

           manifest_path = plugin_path / "manifest.yaml"
           if not manifest_path.exists():
               logger.debug(f"Skipping {plugin_path.name}: no manifest.yaml")
               continue

           try:
               # Load manifest
               with open(manifest_path) as f:
                   manifest_data = yaml.safe_load(f)
               manifest = PluginManifest(**manifest_data)

               # Check if disabled
               if manifest.name in disabled_plugins:
                   logger.info(f"Plugin {manifest.name} is disabled")
                   continue

               # Load plugin module
               entry_path = plugin_path / f"{manifest.entry_point}.py"
               if not entry_path.exists():
                   logger.warning(f"Plugin {manifest.name}: entry point not found")
                   continue

               spec = importlib.util.spec_from_file_location(
                   f"hfs_plugin_{manifest.name.replace('-', '_')}",
                   entry_path
               )
               if spec and spec.loader:
                   module = importlib.util.module_from_spec(spec)
                   sys.modules[spec.name] = module
                   spec.loader.exec_module(module)
                   plugins.append(DiscoveredPlugin(manifest, module, plugin_path))
                   logger.info(f"Loaded plugin: {manifest.name} v{manifest.version}")

           except Exception as e:
               logger.error(f"Failed to load plugin {plugin_path.name}: {e}")
               # Continue loading other plugins

       return plugins

2. Create hfs/plugins/permissions.py:

   from pathlib import Path
   from enum import Enum
   from pydantic import BaseModel
   import yaml
   import logging

   logger = logging.getLogger(__name__)

   class PluginCapability(str, Enum):
       """Plugin capabilities requiring permission."""
       COMMANDS = "commands"      # Register slash commands
       WIDGETS = "widgets"        # Add UI widgets
       HOOKS = "hooks"            # Lifecycle hooks
       FILESYSTEM = "filesystem"  # File system access
       NETWORK = "network"        # Network access

   class PluginPermission(BaseModel):
       """Stored permission for a plugin."""
       plugin_name: str
       plugin_version: str
       capabilities: list[str]
       approved: bool
       approved_at: str | None = None

   class PermissionManager:
       """Manages plugin permission approvals.

       Permissions stored in: ~/.hfs/plugin_permissions.yaml
       """

       def __init__(self, permissions_path: Path | None = None):
           self._path = permissions_path or (Path.home() / ".hfs" / "plugin_permissions.yaml")
           self._permissions: dict[str, PluginPermission] = {}
           self._load()

       def _load(self) -> None:
           """Load permissions from file."""
           if self._path.exists():
               try:
                   with open(self._path) as f:
                       data = yaml.safe_load(f) or {}
                   for name, perm_data in data.items():
                       self._permissions[name] = PluginPermission(**perm_data)
               except Exception as e:
                   logger.error(f"Failed to load permissions: {e}")

       def _save(self) -> None:
           """Save permissions to file."""
           self._path.parent.mkdir(parents=True, exist_ok=True)
           data = {name: perm.model_dump() for name, perm in self._permissions.items()}
           with open(self._path, "w") as f:
               yaml.dump(data, f)

       def is_approved(self, plugin_name: str, capabilities: list[str]) -> bool:
           """Check if plugin has approved permissions for all capabilities."""
           perm = self._permissions.get(plugin_name)
           if not perm or not perm.approved:
               return False
           return all(cap in perm.capabilities for cap in capabilities)

       def approve(self, plugin_name: str, plugin_version: str, capabilities: list[str]) -> None:
           """Approve plugin with capabilities."""
           from datetime import datetime
           self._permissions[plugin_name] = PluginPermission(
               plugin_name=plugin_name,
               plugin_version=plugin_version,
               capabilities=capabilities,
               approved=True,
               approved_at=datetime.utcnow().isoformat(),
           )
           self._save()

       def revoke(self, plugin_name: str) -> None:
           """Revoke plugin permissions."""
           if plugin_name in self._permissions:
               del self._permissions[plugin_name]
               self._save()

       def list_approved(self) -> list[PluginPermission]:
           """List all approved plugins."""
           return [p for p in self._permissions.values() if p.approved]

3. Create hfs/plugins/__init__.py:
   Export: PluginManifest, DiscoveredPlugin, discover_plugins
   Export: PermissionManager, PluginCapability, PluginPermission
  </action>
  <verify>
    python -c "from hfs.plugins import discover_plugins, PluginManifest, PermissionManager; print('OK')"
  </verify>
  <done>
    discover_plugins() scans ~/.hfs/plugins/ and loads valid plugins.
    PluginManifest validates manifest.yaml structure.
    PermissionManager tracks approvals in ~/.hfs/plugin_permissions.yaml.
    Bad plugins are logged and skipped (don't crash app).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create hook system and PluginManager</name>
  <files>
    hfs/plugins/hooks.py
    hfs/plugins/manager.py
    hfs/plugins/__init__.py
  </files>
  <action>
1. Create hfs/plugins/hooks.py:

   from typing import Protocol, Any
   from hfs.state.models import RunSnapshot

   class HFSHookSpec(Protocol):
       """Hook specifications that plugins can implement.

       Plugins implement these methods to receive lifecycle events.
       All hooks are optional - implement only what you need.

       Example plugin:
           class MyPlugin:
               def on_start(self, session_id: str) -> None:
                   print(f"Session started: {session_id}")

               def on_message(self, message: str, is_user: bool) -> str | None:
                   # Return modified message or None to pass through
                   return None
       """

       def on_start(self, session_id: str) -> None:
           """Called when HFS session starts.

           Args:
               session_id: The session ID string
           """
           ...

       def on_message(self, message: str, is_user: bool) -> str | None:
           """Called for each message.

           Can modify the message by returning a new string,
           or return None to pass through unchanged.

           Args:
               message: The message content
               is_user: True if user message, False if assistant

           Returns:
               Modified message or None
           """
           ...

       def on_run_complete(self, run_snapshot: RunSnapshot) -> None:
           """Called when an agent run completes.

           Args:
               run_snapshot: The complete run state snapshot
           """
           ...

       def on_exit(self) -> None:
           """Called when HFS is exiting."""
           ...

   # List of all hook names for validation
   HOOK_NAMES = ["on_start", "on_message", "on_run_complete", "on_exit"]

2. Create hfs/plugins/manager.py:

   import logging
   from typing import Any, Callable
   from .discovery import DiscoveredPlugin, discover_plugins
   from .permissions import PermissionManager
   from .hooks import HOOK_NAMES

   logger = logging.getLogger(__name__)

   class PluginManager:
       """Manages plugin lifecycle and hook execution.

       Responsibilities:
       - Load plugins from discovery
       - Check permissions (prompt if needed)
       - Register commands from plugins
       - Call hooks at appropriate times
       """

       def __init__(
           self,
           permission_manager: PermissionManager | None = None,
           disabled_plugins: list[str] | None = None,
       ):
           self._permission_manager = permission_manager or PermissionManager()
           self._disabled_plugins = disabled_plugins or []
           self._plugins: list[DiscoveredPlugin] = []
           self._commands: dict[str, Callable] = {}  # /cmd -> handler
           self._pending_approval: list[DiscoveredPlugin] = []

       def load_plugins(self) -> int:
           """Discover and load all plugins.

           Returns:
               Number of plugins loaded
           """
           discovered = discover_plugins(disabled_plugins=self._disabled_plugins)

           for plugin in discovered:
               # Check permissions
               if not self._permission_manager.is_approved(
                   plugin.manifest.name,
                   plugin.manifest.capabilities,
               ):
                   self._pending_approval.append(plugin)
                   logger.info(f"Plugin {plugin.manifest.name} pending approval")
                   continue

               self._activate_plugin(plugin)

           return len(self._plugins)

       def _activate_plugin(self, plugin: DiscoveredPlugin) -> None:
           """Activate a plugin after approval."""
           self._plugins.append(plugin)

           # Register commands if plugin has them
           if "commands" in plugin.manifest.capabilities:
               commands = getattr(plugin.module, "COMMANDS", {})
               for cmd_name, handler in commands.items():
                   full_cmd = f"/{cmd_name}" if not cmd_name.startswith("/") else cmd_name
                   self._commands[full_cmd] = handler
                   logger.info(f"Registered command {full_cmd} from {plugin.manifest.name}")

       def get_pending_approvals(self) -> list[DiscoveredPlugin]:
           """Get plugins waiting for permission approval."""
           return self._pending_approval

       def approve_plugin(self, plugin_name: str) -> bool:
           """Approve a pending plugin.

           Returns:
               True if plugin was found and approved
           """
           for plugin in self._pending_approval[:]:
               if plugin.manifest.name == plugin_name:
                   self._permission_manager.approve(
                       plugin.manifest.name,
                       plugin.manifest.version,
                       plugin.manifest.capabilities,
                   )
                   self._activate_plugin(plugin)
                   self._pending_approval.remove(plugin)
                   return True
           return False

       def deny_plugin(self, plugin_name: str) -> bool:
           """Deny a pending plugin."""
           for plugin in self._pending_approval[:]:
               if plugin.manifest.name == plugin_name:
                   self._pending_approval.remove(plugin)
                   return True
           return False

       def get_commands(self) -> dict[str, Callable]:
           """Get all registered plugin commands."""
           return self._commands

       def has_command(self, command: str) -> bool:
           """Check if a command is registered by a plugin."""
           return command in self._commands

       async def call_command(self, command: str, text: str) -> Any:
           """Call a plugin command.

           Args:
               command: The command name (e.g., "/mycmd")
               text: Full command text

           Returns:
               Command handler result
           """
           handler = self._commands.get(command)
           if handler:
               import asyncio
               if asyncio.iscoroutinefunction(handler):
                   return await handler(text)
               return handler(text)
           return None

       async def call_hook(self, hook_name: str, **kwargs) -> list[Any]:
           """Call a hook on all plugins that implement it.

           Args:
               hook_name: Name of hook (on_start, on_message, etc.)
               **kwargs: Arguments to pass to hook

           Returns:
               List of non-None results from plugins
           """
           if hook_name not in HOOK_NAMES:
               logger.warning(f"Unknown hook: {hook_name}")
               return []

           results = []
           for plugin in self._plugins:
               if "hooks" not in plugin.manifest.capabilities:
                   continue

               hook = getattr(plugin.module, hook_name, None)
               if hook is None:
                   continue

               try:
                   import asyncio
                   if asyncio.iscoroutinefunction(hook):
                       result = await hook(**kwargs)
                   else:
                       result = hook(**kwargs)
                   if result is not None:
                       results.append(result)
               except Exception as e:
                   logger.error(f"Hook {hook_name} failed in {plugin.manifest.name}: {e}")

           return results

       def get_loaded_plugins(self) -> list[DiscoveredPlugin]:
           """Get list of loaded plugins."""
           return self._plugins

3. Update hfs/plugins/__init__.py:
   Export: HFSHookSpec, HOOK_NAMES, PluginManager
  </action>
  <verify>
    python -c "from hfs.plugins import PluginManager, HFSHookSpec; print('OK')"
  </verify>
  <done>
    HFSHookSpec defines hook protocol (on_start, on_message, on_run_complete, on_exit).
    PluginManager handles discovery, permissions, command registration, hook calls.
    Pending approval list for new plugins.
    Commands registered via COMMANDS dict in plugin module.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire plugins to TUI with permission prompts and commands</name>
  <files>
    hfs/tui/app.py
    hfs/tui/screens/chat.py
    hfs/user_config/models.py
  </files>
  <action>
1. Update hfs/user_config/models.py:
   - Add disabled_plugins: list[str] = [] field
   - Update get_field_names() (but not get_valid_values - it's a list)

2. Update hfs/tui/app.py:

   Add _plugin_manager: PluginManager | None = None

   Add async def initialize_plugins(self) -> None:
       """Initialize plugin system."""
       from hfs.plugins import PluginManager

       config = self.get_user_config()
       disabled = config.disabled_plugins if hasattr(config, 'disabled_plugins') else []

       self._plugin_manager = PluginManager(disabled_plugins=disabled)
       loaded = self._plugin_manager.load_plugins()

       if loaded > 0:
           logger.info(f"Loaded {loaded} plugin(s)")

       # Check for pending approvals
       pending = self._plugin_manager.get_pending_approvals()
       if pending:
           # Schedule permission prompt after mount
           self._pending_plugin_approvals = pending

   Add get_plugin_manager(self) -> PluginManager | None

   Update on_mount to call initialize_plugins() after initialize_persistence()

   Add async def _prompt_plugin_approval(self) -> None:
       """Prompt for plugin permissions via chat message."""
       # Called from ChatScreen on_mount if there are pending approvals

3. Update hfs/tui/screens/chat.py:

   Add to SLASH_COMMANDS:
       "/plugins": "handle_plugins"

   Update on_chat_input_submitted:
       - Before checking SLASH_COMMANDS, check plugin_manager.has_command(cmd)
       - If yes, call plugin_manager.call_command(cmd, text) and return

   Update send_message:
       - Before sending: results = await plugin_manager.call_hook("on_message", message=text, is_user=True)
       - If any result is string, use it as modified message
       - After response complete: call on_run_complete hook if we have snapshot

   Update on_mount:
       - Check for pending plugin approvals
       - If any, show message:
         "**New plugins detected:**\n\n"
         "| Plugin | Version | Capabilities |\n"
         "| my-plugin | 1.0.0 | commands, hooks |\n\n"
         "Type `/plugins approve <name>` or `/plugins deny <name>`"

   Add async def handle_plugins(self, text: str) -> None:
       """Handle /plugins command.

       Subcommands:
           /plugins - List loaded and pending plugins
           /plugins approve <name> - Approve pending plugin
           /plugins deny <name> - Deny pending plugin
           /plugins disable <name> - Disable a loaded plugin (requires restart)
       """
       message_list = self.query_one("#messages", MessageList)
       plugin_manager = self.app.get_plugin_manager()

       if not plugin_manager:
           await message_list.add_message("Plugin system not available.", is_system=True)
           return

       parts = text.strip().split()

       # /plugins (list)
       if len(parts) == 1:
           loaded = plugin_manager.get_loaded_plugins()
           pending = plugin_manager.get_pending_approvals()

           lines = ["**Plugins**\n"]

           if loaded:
               lines.append("**Loaded:**")
               lines.append("| Name | Version | Capabilities |")
               lines.append("|------|---------|--------------|")
               for p in loaded:
                   caps = ", ".join(p.manifest.capabilities)
                   lines.append(f"| {p.manifest.name} | {p.manifest.version} | {caps} |")
               lines.append("")

           if pending:
               lines.append("**Pending Approval:**")
               lines.append("| Name | Version | Capabilities |")
               lines.append("|------|---------|--------------|")
               for p in pending:
                   caps = ", ".join(p.manifest.capabilities)
                   lines.append(f"| {p.manifest.name} | {p.manifest.version} | {caps} |")
               lines.append("\nUse `/plugins approve <name>` or `/plugins deny <name>`")

           if not loaded and not pending:
               lines.append("No plugins found.\n\nPlugins go in `~/.hfs/plugins/<plugin_name>/`")

           await message_list.add_message("\n".join(lines), is_system=True)
           return

       # /plugins approve <name>
       if len(parts) >= 3 and parts[1] == "approve":
           name = parts[2]
           if plugin_manager.approve_plugin(name):
               await message_list.add_message(
                   f"**Plugin approved:** `{name}`\n\nPlugin is now active.",
                   is_system=True,
               )
           else:
               await message_list.add_message(
                   f"Plugin `{name}` not found in pending list.",
                   is_system=True,
               )
           return

       # /plugins deny <name>
       if len(parts) >= 3 and parts[1] == "deny":
           name = parts[2]
           if plugin_manager.deny_plugin(name):
               await message_list.add_message(
                   f"**Plugin denied:** `{name}`",
                   is_system=True,
               )
           else:
               await message_list.add_message(
                   f"Plugin `{name}` not found in pending list.",
                   is_system=True,
               )
           return

       # Unknown subcommand
       await message_list.add_message(
           "**Usage:**\n"
           "- `/plugins` - List all plugins\n"
           "- `/plugins approve <name>` - Approve pending plugin\n"
           "- `/plugins deny <name>` - Deny pending plugin",
           is_system=True,
       )

   Update CommandCompleter to include plugin commands in completions.
  </action>
  <verify>
    python -c "from hfs.tui.screens import ChatScreen; print('OK')"
    python -c "from hfs.plugins import PluginManager; pm = PluginManager(); pm.load_plugins(); print('Plugins loaded:', len(pm.get_loaded_plugins()))"
  </verify>
  <done>
    /plugins lists loaded and pending plugins.
    /plugins approve activates pending plugin.
    /plugins deny rejects pending plugin.
    Plugin commands work via has_command() and call_command().
    Lifecycle hooks called at appropriate times (on_message, on_run_complete).
    Permission approval persists in ~/.hfs/plugin_permissions.yaml.
  </done>
</task>

</tasks>

<verification>
1. Run: python -c "from hfs.plugins import *" (imports work)
2. Create test plugin:
   mkdir -p ~/.hfs/plugins/test-plugin
   Create ~/.hfs/plugins/test-plugin/manifest.yaml:
     name: test-plugin
     version: 1.0.0
     capabilities: [commands, hooks]
   Create ~/.hfs/plugins/test-plugin/__init__.py:
     COMMANDS = {"test": lambda text: print(f"Test command: {text}")}
     def on_message(message, is_user):
         if is_user:
             print(f"Plugin saw message: {message}")
         return None
3. Run: hfs
4. Should see "New plugins detected" message
5. /plugins (shows test-plugin in pending)
6. /plugins approve test-plugin
7. /plugins (shows test-plugin in loaded)
8. /test hello (plugin command works)
9. Send message (plugin on_message hook fires)
10. Exit, restart hfs (plugin loads automatically - already approved)
</verification>

<success_criteria>
- Plugin discovery scans ~/.hfs/plugins/
- Plugins require manifest.yaml with name, version, capabilities
- Permission prompt on first load (approve/deny)
- Approved permissions persist in ~/.hfs/plugin_permissions.yaml
- Plugin commands registered via COMMANDS dict
- Lifecycle hooks called (on_start, on_message, on_run_complete, on_exit)
- Bad plugins logged and skipped (don't crash app)
- /plugins command for management
</success_criteria>

<output>
After completion, create `.planning/phases/13-persistence-plugins/13-04-SUMMARY.md`
</output>
