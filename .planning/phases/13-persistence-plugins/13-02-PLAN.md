---
phase: 13-persistence-plugins
plan: 02
type: execute
wave: 2
depends_on: ["13-01"]
files_modified:
  - hfs/persistence/models.py
  - hfs/persistence/repository.py
  - hfs/persistence/checkpoint.py
  - hfs/tui/screens/chat.py
  - hfs/tui/app.py
  - hfs/user_config/models.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Automatic checkpoints trigger after each agent run completes"
    - "Automatic checkpoints trigger at key state changes (negotiation resolved, phase ended)"
    - "User can list checkpoints with /checkpoints command showing ASCII timeline"
    - "User can rewind to a previous checkpoint, preserving original history"
    - "Checkpoint retention respects configurable limit (default 10)"
  artifacts:
    - path: "hfs/persistence/checkpoint.py"
      provides: "CheckpointService with event-driven auto-checkpointing"
      exports: ["CheckpointService"]
    - path: "hfs/persistence/models.py"
      provides: "CheckpointModel added"
      contains: "class CheckpointModel"
    - path: "hfs/persistence/repository.py"
      provides: "CheckpointRepository added"
      exports: ["CheckpointRepository"]
  key_links:
    - from: "hfs/persistence/checkpoint.py"
      to: "hfs/events/bus.py"
      via: "EventBus subscription for checkpoint triggers"
      pattern: "await.*event_bus\\.subscribe"
    - from: "hfs/tui/screens/chat.py"
      to: "hfs/persistence/repository.py"
      via: "Checkpoint commands"
      pattern: "checkpoint_repo"
---

<objective>
Implement automatic checkpointing system that captures state at key moments.

Purpose: Enable users to list checkpoints with a visual ASCII timeline and rewind to any previous checkpoint. Checkpoints create branches, preserving original history (like git branches).

Output: Working /checkpoints and /rewind commands with event-driven auto-checkpointing.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/13-persistence-plugins/13-RESEARCH.md
@.planning/phases/13-persistence-plugins/13-01-SUMMARY.md

# Existing code to integrate with
@hfs/persistence/models.py
@hfs/persistence/repository.py
@hfs/events/bus.py
@hfs/state/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add CheckpointModel and CheckpointRepository</name>
  <files>
    hfs/persistence/models.py
    hfs/persistence/repository.py
    hfs/persistence/__init__.py
    hfs/user_config/models.py
  </files>
  <action>
1. Update hfs/persistence/models.py - add CheckpointModel:

   class CheckpointModel(Base):
       __tablename__ = "checkpoints"

       id: Mapped[int] = mapped_column(primary_key=True)
       session_id: Mapped[int] = mapped_column(ForeignKey("sessions.id"))
       message_index: Mapped[int]  # Position in conversation (for timeline)
       trigger_event: Mapped[str] = mapped_column(String(100))  # run.ended, negotiation.resolved, etc.
       state_json: Mapped[str] = mapped_column(Text)  # RunSnapshot serialized
       created_at: Mapped[datetime]

       session: Mapped["SessionModel"] = relationship(back_populates="checkpoints")

   Update SessionModel to add:
       checkpoints: Mapped[list["CheckpointModel"]] = relationship(
           back_populates="session",
           lazy="selectin",
           cascade="all, delete-orphan"
       )

2. Update hfs/persistence/repository.py - add CheckpointRepository:

   class CheckpointRepository:
       def __init__(self, session_factory: async_sessionmaker[AsyncSession])

       Methods:
       a) async def create(
           self,
           session_id: int,
           message_index: int,
           trigger_event: str,
           state_json: str
       ) -> CheckpointModel

       b) async def list_for_session(self, session_id: int) -> list[CheckpointModel]
          - Order by message_index ASC

       c) async def get(self, checkpoint_id: int) -> CheckpointModel | None

       d) async def prune_oldest(self, session_id: int, keep_count: int) -> int
          - Delete oldest checkpoints beyond keep_count
          - Return number deleted

3. Update hfs/user_config/models.py:
   - Add checkpoint_retention: int = 10 field to UserConfig
   - Update get_valid_values() and get_field_names()

4. Update hfs/persistence/__init__.py to export:
   - CheckpointModel
   - CheckpointRepository
  </action>
  <verify>
    python -c "from hfs.persistence import CheckpointModel, CheckpointRepository; print('OK')"
    python -c "from hfs.user_config import UserConfig; c = UserConfig(); print(f'retention={c.checkpoint_retention}')"
  </verify>
  <done>
    CheckpointModel exists with session_id, message_index, trigger_event, state_json.
    CheckpointRepository has create, list_for_session, get, prune_oldest methods.
    UserConfig has checkpoint_retention setting defaulting to 10.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CheckpointService with event-driven auto-checkpointing</name>
  <files>
    hfs/persistence/checkpoint.py
    hfs/persistence/__init__.py
  </files>
  <action>
Create hfs/persistence/checkpoint.py:

class CheckpointService:
    """Event-driven automatic checkpointing.

    Subscribes to EventBus and creates checkpoints at key state changes:
    - run.ended: After each agent run completes
    - negotiation.resolved: When negotiation reaches resolution
    - phase.ended: At phase transitions
    """

    CHECKPOINT_EVENTS = {
        "run.ended",
        "negotiation.resolved",
        "phase.ended",
    }

    def __init__(
        self,
        event_bus: EventBus,
        checkpoint_repo: CheckpointRepository,
        state_manager: StateManager | None = None,
        retention_limit: int = 10,
    ):
        self._event_bus = event_bus
        self._checkpoint_repo = checkpoint_repo
        self._state_manager = state_manager
        self._retention_limit = retention_limit
        self._current_session_id: int | None = None
        self._current_message_index: int = 0
        self._stream: EventStream | None = None
        self._task: asyncio.Task | None = None

    async def start(self) -> None:
        """Start listening for checkpoint events."""
        self._stream = await self._event_bus.subscribe("*")
        self._task = asyncio.create_task(self._process_events())

    async def stop(self) -> None:
        """Stop listening and cleanup."""
        if self._task:
            self._task.cancel()
            try:
                await self._task
            except asyncio.CancelledError:
                pass
        if self._stream:
            await self._event_bus.unsubscribe(self._stream)

    def set_session(self, session_id: int, message_count: int) -> None:
        """Set current session for checkpoints."""
        self._current_session_id = session_id
        self._current_message_index = message_count

    def increment_message_index(self) -> None:
        """Increment message index after each message."""
        self._current_message_index += 1

    async def _process_events(self) -> None:
        """Process events and create checkpoints."""
        async for event in self._stream:
            if event.event_type in self.CHECKPOINT_EVENTS:
                await self._create_checkpoint(event)

    async def _create_checkpoint(self, event: HFSEvent) -> None:
        """Create checkpoint from event."""
        if self._current_session_id is None:
            return

        # Get current state snapshot
        state_json = "{}"  # Default if no state manager
        if self._state_manager:
            snapshot = self._state_manager.get_snapshot()
            if snapshot:
                state_json = snapshot.model_dump_json()

        # Create checkpoint
        await self._checkpoint_repo.create(
            session_id=self._current_session_id,
            message_index=self._current_message_index,
            trigger_event=event.event_type,
            state_json=state_json,
        )

        # Prune old checkpoints
        await self._checkpoint_repo.prune_oldest(
            self._current_session_id,
            self._retention_limit,
        )

    async def create_manual_checkpoint(self, trigger: str = "manual") -> CheckpointModel | None:
        """Create a manual checkpoint."""
        if self._current_session_id is None:
            return None

        state_json = "{}"
        if self._state_manager:
            snapshot = self._state_manager.get_snapshot()
            if snapshot:
                state_json = snapshot.model_dump_json()

        return await self._checkpoint_repo.create(
            session_id=self._current_session_id,
            message_index=self._current_message_index,
            trigger_event=trigger,
            state_json=state_json,
        )

Update hfs/persistence/__init__.py to export CheckpointService.
  </action>
  <verify>
    python -c "from hfs.persistence import CheckpointService; print('OK')"
  </verify>
  <done>
    CheckpointService subscribes to EventBus and auto-creates checkpoints.
    Respects retention limit by pruning oldest checkpoints.
    Supports manual checkpoint creation.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire checkpoints to TUI with slash commands</name>
  <files>
    hfs/tui/app.py
    hfs/tui/screens/chat.py
  </files>
  <action>
1. Update hfs/tui/app.py:
   - Add _checkpoint_repo: CheckpointRepository | None = None
   - Add _checkpoint_service: CheckpointService | None = None

   - In initialize_persistence():
     - Create CheckpointRepository with session factory
     - Create CheckpointService with event_bus (if available), checkpoint_repo
     - Load checkpoint_retention from user config
     - Start CheckpointService

   - Add get_checkpoint_repo(self) -> CheckpointRepository | None
   - Add get_checkpoint_service(self) -> CheckpointService | None

2. Update hfs/tui/screens/chat.py:

   Add to SLASH_COMMANDS:
     "/checkpoints": "handle_checkpoints"
     "/rewind": "handle_rewind"
     "/checkpoint": "handle_create_checkpoint"

   Add async def handle_checkpoints(self, text: str) -> None:
     - Get checkpoint_repo from app
     - Get current_session_id from app
     - Call list_for_session(session_id)
     - Format as visual ASCII timeline:

       ```
       **Checkpoints for Session**

       Timeline:
       [1] --> [3] --> [5] --> [8] --> [10]
        |       |       |       |       |
       run   phase  negot.  run    run
       ended  ended  resol.  ended  ended

       | # | Msg | Event | Time |
       |---|-----|-------|------|
       | 1 | 1   | run.ended | 14:30 |
       | 2 | 3   | phase.ended | 14:32 |
       ...

       Use `/rewind <#>` to restore to a checkpoint.
       ```

   Add async def handle_rewind(self, text: str) -> None:
     - Parse "/rewind <checkpoint_number>" (1-indexed from list)
     - Get checkpoint by ID
     - BRANCHING: Create new session with name "{original_name} (rewind from #{n})"
     - Copy messages up to checkpoint.message_index
     - Set as current session
     - Reload messages into MessageList
     - Show "Rewound to checkpoint #{n}. Original session preserved."

   Add async def handle_create_checkpoint(self, text: str) -> None:
     - Call checkpoint_service.create_manual_checkpoint("manual")
     - Show "Checkpoint created at message #{index}"

   Update send_message:
     - After adding each message, call checkpoint_service.increment_message_index()
     - Ensure checkpoint_service.set_session() called when session created/resumed
  </action>
  <verify>
    python -c "from hfs.tui.screens import ChatScreen; print('OK')"
    # Manual: hfs, send messages, /checkpoints shows timeline
  </verify>
  <done>
    /checkpoints shows visual ASCII timeline with checkpoint positions.
    /rewind creates branch from checkpoint, preserving original.
    /checkpoint creates manual checkpoint.
    Auto-checkpoints fire on key events (when event bus wired).
  </done>
</task>

</tasks>

<verification>
1. Run: python -c "from hfs.persistence import CheckpointService, CheckpointRepository"
2. Run: hfs (TUI starts without errors)
3. Send several messages
4. /checkpoints (shows timeline with any auto-created checkpoints)
5. /checkpoint (creates manual checkpoint, shows confirmation)
6. /checkpoints (manual checkpoint appears)
7. /rewind 1 (creates new session branched from checkpoint 1)
8. /sessions (shows both original and rewound sessions)
9. Check config: /config (shows checkpoint_retention setting)
</verification>

<success_criteria>
- CheckpointModel stores session_id, message_index, trigger_event, state_json
- CheckpointService subscribes to EventBus and auto-checkpoints
- /checkpoints displays visual ASCII timeline
- /rewind creates branch from checkpoint (preserves original)
- /checkpoint creates manual checkpoint
- checkpoint_retention config limits stored checkpoints (default 10)
</success_criteria>

<output>
After completion, create `.planning/phases/13-persistence-plugins/13-02-SUMMARY.md`
</output>
