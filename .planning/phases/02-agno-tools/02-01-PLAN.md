---
phase: 02-agno-tools
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - hfs/agno/tools/__init__.py
  - hfs/agno/tools/schemas.py
  - hfs/agno/tools/errors.py
  - hfs/agno/tools/toolkit.py
  - hfs/agno/__init__.py
  - hfs/tests/test_hfs_toolkit.py
autonomous: true

must_haves:
  truths:
    - "register_claim tool accepts section_id and proposal, returns claim status"
    - "negotiate_response tool accepts section_id, decision (concede/revise/hold), optional revised_proposal"
    - "generate_code tool accepts section_id, returns placeholder for code generation"
    - "get_current_claims tool returns spec state grouped by status"
    - "get_negotiation_state tool returns proposals and claimants for contested sections"
    - "ValidationError on invalid input returns retry-friendly JSON with hints"
  artifacts:
    - path: "hfs/agno/tools/schemas.py"
      provides: "Pydantic input/output models for all tools"
      contains: "class RegisterClaimInput"
    - path: "hfs/agno/tools/errors.py"
      provides: "Error formatting utilities"
      contains: "def format_validation_error"
    - path: "hfs/agno/tools/toolkit.py"
      provides: "HFSToolkit class with 5 tool methods"
      contains: "class HFSToolkit"
    - path: "hfs/tests/test_hfs_toolkit.py"
      provides: "Unit tests for toolkit"
      contains: "def test_register_claim"
  key_links:
    - from: "hfs/agno/tools/toolkit.py"
      to: "hfs/core/spec.py"
      via: "Spec passed to HFSToolkit.__init__"
      pattern: "self._spec"
    - from: "hfs/agno/tools/toolkit.py"
      to: "hfs/agno/tools/schemas.py"
      via: "Import Pydantic models for validation"
      pattern: "from .schemas import"
    - from: "hfs/agno/__init__.py"
      to: "hfs/agno/tools/toolkit.py"
      via: "Export HFSToolkit"
      pattern: "from .tools import HFSToolkit"
---

<objective>
Implement HFS-specific Agno tools as an HFSToolkit class with Pydantic validation, LLM-optimized docstrings, and retry-friendly error handling.

Purpose: Enable Agno agents to interact with HFS spec during deliberation, negotiation, and execution phases via typed, validated tool calls.
Output: HFSToolkit class with 5 tools (register_claim, negotiate_response, generate_code, get_current_claims, get_negotiation_state) and comprehensive unit tests.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-agno-tools/02-CONTEXT.md
@.planning/phases/02-agno-tools/02-RESEARCH.md

# Key source files the tools interact with
@hfs/core/spec.py
@hfs/agno/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic schemas and error utilities</name>
  <files>
    hfs/agno/tools/__init__.py
    hfs/agno/tools/schemas.py
    hfs/agno/tools/errors.py
  </files>
  <action>
Create the hfs/agno/tools/ directory structure with:

**schemas.py** - Pydantic models for tool inputs and outputs:

```python
from pydantic import BaseModel, Field, field_validator
from typing import Optional, List, Dict, Any, Literal
from enum import Enum

class NegotiationDecision(str, Enum):
    CONCEDE = "concede"
    REVISE = "revise"
    HOLD = "hold"

# Input models
class RegisterClaimInput(BaseModel):
    section_id: str = Field(..., min_length=1, max_length=128)
    proposal: str = Field(..., min_length=1)

    @field_validator('section_id')
    @classmethod
    def strip_section_id(cls, v): return v.strip()

class NegotiateResponseInput(BaseModel):
    section_id: str = Field(..., min_length=1)
    decision: NegotiationDecision
    revised_proposal: Optional[str] = None

    @field_validator('revised_proposal')
    @classmethod
    def require_proposal_for_revise(cls, v, info):
        if info.data.get('decision') == NegotiationDecision.REVISE and not v:
            raise ValueError("revised_proposal required when decision is 'revise'")
        return v

class GenerateCodeInput(BaseModel):
    section_id: str = Field(..., min_length=1)

# Output models - all have success, message, and tool-specific fields
class ToolOutput(BaseModel):
    success: bool
    message: str

class RegisterClaimOutput(ToolOutput):
    section_id: str
    status: str  # unclaimed, claimed, contested, frozen
    current_claimants: List[str]

class NegotiateResponseOutput(ToolOutput):
    section_id: str
    decision: str
    round_number: int
    participants: List[str]

class GenerateCodeOutput(ToolOutput):
    section_id: str
    code: Optional[str] = None

class ClaimsStateOutput(ToolOutput):
    unclaimed: List[str]
    claimed: List[str]
    contested: List[str]
    frozen: List[str]
    your_claims: List[str]
    temperature: float
    round: int

class NegotiationStateOutput(ToolOutput):
    contested_sections: Dict[str, Any]
    total_contested: int

class ErrorOutput(BaseModel):
    success: bool = False
    error: str
    message: str
    hints: List[str] = []
    retry_allowed: bool = True
```

**errors.py** - Error formatting utilities:

```python
from pydantic import ValidationError
import json
from typing import List

def format_validation_error(error: ValidationError) -> str:
    """Convert ValidationError to LLM-friendly JSON with hints."""
    hints: List[str] = []
    for err in error.errors():
        field = ".".join(str(loc) for loc in err["loc"])
        msg = err["msg"]
        hints.append(f"{field}: {msg}")

    return json.dumps({
        "success": False,
        "error": "validation_error",
        "message": "Invalid input. Please fix and retry.",
        "hints": hints,
        "retry_allowed": True,
    })

def format_runtime_error(error: Exception, context: str = "") -> str:
    """Convert runtime errors to non-retryable JSON response."""
    return json.dumps({
        "success": False,
        "error": "runtime_error",
        "message": str(error),
        "context": context,
        "retry_allowed": False,
    })
```

**__init__.py** - Export HFSToolkit (will be added in Task 2):

```python
"""HFS Tools for Agno agents."""
from .toolkit import HFSToolkit
from .schemas import (
    NegotiationDecision,
    RegisterClaimInput,
    NegotiateResponseInput,
    GenerateCodeInput,
)

__all__ = [
    "HFSToolkit",
    "NegotiationDecision",
    "RegisterClaimInput",
    "NegotiateResponseInput",
    "GenerateCodeInput",
]
```

Design decisions per CONTEXT.md:
- Strict validation with min_length constraints
- Cross-field validation (revised_proposal required for REVISE)
- Consistent output wrapper (success, message + tool-specific)
- retry_allowed flag distinguishes recoverable errors
  </action>
  <verify>
```bash
cd hfs && python -c "from agno.tools.schemas import RegisterClaimInput, NegotiationDecision; print('schemas OK')"
cd hfs && python -c "from agno.tools.errors import format_validation_error; print('errors OK')"
```
  </verify>
  <done>
- schemas.py contains all Pydantic input/output models
- errors.py contains format_validation_error and format_runtime_error
- All models importable without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement HFSToolkit with 5 tool methods</name>
  <files>
    hfs/agno/tools/toolkit.py
    hfs/agno/__init__.py
  </files>
  <action>
Create HFSToolkit class extending agno.tools.Toolkit with all 5 tools.

**toolkit.py**:

```python
from agno.tools import Toolkit
from typing import Callable, List, Optional, TYPE_CHECKING
from pydantic import ValidationError
import json

from .schemas import (
    RegisterClaimInput, RegisterClaimOutput,
    NegotiateResponseInput, NegotiateResponseOutput, NegotiationDecision,
    GenerateCodeInput, GenerateCodeOutput,
    ClaimsStateOutput, NegotiationStateOutput,
)
from .errors import format_validation_error, format_runtime_error

if TYPE_CHECKING:
    from hfs.core.spec import Spec

class HFSToolkit(Toolkit):
    """HFS operation tools with shared spec state access.

    Provides tools for Agno agents to interact with the HFS spec during
    deliberation, negotiation, and execution phases.
    """

    def __init__(self, spec: "Spec", triad_id: str, **kwargs):
        self._spec = spec
        self._triad_id = triad_id

        tools: List[Callable] = [
            self.register_claim,
            self.negotiate_response,
            self.generate_code,
            self.get_current_claims,
            self.get_negotiation_state,
        ]
        super().__init__(name="hfs_tools", tools=tools, **kwargs)
```

For each tool method, include LLM-optimized docstrings with:
- WHEN TO USE section
- IMPORTANT CONSTRAINTS section
- EXAMPLE section
- Clear Args and Returns

**register_claim**:
- Validate with RegisterClaimInput
- Call self._spec.register_claim(triad_id, section_id, proposal)
- Return RegisterClaimOutput with section status and claimants

**negotiate_response**:
- Validate with NegotiateResponseInput
- For CONCEDE: call self._spec.concede()
- For REVISE: call self._spec.update_proposal()
- For HOLD: no action
- Return NegotiateResponseOutput with round number and participants

**generate_code**:
- Validate with GenerateCodeInput
- Verify spec is frozen and triad owns section
- Return GenerateCodeOutput (code field is placeholder for Phase 3+)

**get_current_claims**:
- No inputs needed
- Return ClaimsStateOutput with all section lists and your_claims

**get_negotiation_state**:
- Optional section_id parameter
- If provided, return single section details
- If not, return all contested sections
- Return NegotiationStateOutput

Error handling pattern for all tools:
```python
try:
    input_model = XXXInput(...)
except ValidationError as e:
    return format_validation_error(e)

try:
    # tool logic
except Exception as e:
    return format_runtime_error(e, "context")
```

Update **hfs/agno/__init__.py** to export HFSToolkit:
```python
from .tools import HFSToolkit
# Add to __all__
```
  </action>
  <verify>
```bash
cd hfs && python -c "
from agno.tools import HFSToolkit
from core.spec import Spec
spec = Spec()
toolkit = HFSToolkit(spec=spec, triad_id='test-triad')
print(f'Toolkit has {len(toolkit.functions)} tools')
print([f.name for f in toolkit.functions])
"
```
  </verify>
  <done>
- HFSToolkit class with 5 methods: register_claim, negotiate_response, generate_code, get_current_claims, get_negotiation_state
- Each method has LLM-optimized docstring with WHEN TO USE, CONSTRAINTS, EXAMPLE
- ValidationError returns retry-friendly JSON
- RuntimeError returns non-retryable JSON
- HFSToolkit exported from hfs.agno
  </done>
</task>

<task type="auto">
  <name>Task 3: Add unit tests for HFSToolkit</name>
  <files>
    hfs/tests/test_hfs_toolkit.py
  </files>
  <action>
Create comprehensive unit tests for HFSToolkit. These are pure unit tests - no API keys needed.

**test_hfs_toolkit.py**:

```python
"""Unit tests for HFSToolkit."""
import pytest
import json
from hfs.agno.tools import HFSToolkit
from hfs.core.spec import Spec

class TestRegisterClaim:
    """Tests for register_claim tool."""

    def test_register_claim_success(self):
        spec = Spec()
        spec.initialize_sections(["header", "footer"])
        toolkit = HFSToolkit(spec=spec, triad_id="triad-1")

        result = json.loads(toolkit.register_claim(
            section_id="header",
            proposal="Navigation with logo"
        ))

        assert result["success"] is True
        assert result["section_id"] == "header"
        assert result["status"] == "claimed"
        assert "triad-1" in result["current_claimants"]

    def test_register_claim_contested(self):
        spec = Spec()
        spec.initialize_sections(["header"])
        spec.register_claim("other-triad", "header", "Their proposal")
        toolkit = HFSToolkit(spec=spec, triad_id="triad-1")

        result = json.loads(toolkit.register_claim(
            section_id="header",
            proposal="My proposal"
        ))

        assert result["success"] is True
        assert result["status"] == "contested"
        assert len(result["current_claimants"]) == 2

    def test_register_claim_validation_error(self):
        spec = Spec()
        toolkit = HFSToolkit(spec=spec, triad_id="triad-1")

        result = json.loads(toolkit.register_claim(
            section_id="",  # Invalid - empty
            proposal="Content"
        ))

        assert result["success"] is False
        assert result["error"] == "validation_error"
        assert result["retry_allowed"] is True
        assert len(result["hints"]) > 0

class TestNegotiateResponse:
    """Tests for negotiate_response tool."""

    def test_concede(self):
        spec = Spec()
        spec.initialize_sections(["header"])
        spec.register_claim("triad-1", "header", "Proposal 1")
        spec.register_claim("triad-2", "header", "Proposal 2")
        toolkit = HFSToolkit(spec=spec, triad_id="triad-1")

        result = json.loads(toolkit.negotiate_response(
            section_id="header",
            decision="concede"
        ))

        assert result["success"] is True
        assert result["decision"] == "concede"
        assert "triad-1" not in spec.sections["header"].claims

    def test_revise_requires_proposal(self):
        spec = Spec()
        toolkit = HFSToolkit(spec=spec, triad_id="triad-1")

        result = json.loads(toolkit.negotiate_response(
            section_id="header",
            decision="revise"
            # Missing revised_proposal
        ))

        assert result["success"] is False
        assert result["retry_allowed"] is True

class TestGetCurrentClaims:
    """Tests for get_current_claims tool."""

    def test_returns_all_categories(self):
        spec = Spec()
        spec.initialize_sections(["sec1", "sec2", "sec3"])
        spec.register_claim("triad-1", "sec1", "P1")
        spec.register_claim("triad-1", "sec2", "P2")
        spec.register_claim("triad-2", "sec2", "P2b")  # contested
        toolkit = HFSToolkit(spec=spec, triad_id="triad-1")

        result = json.loads(toolkit.get_current_claims())

        assert result["success"] is True
        assert "sec3" in result["unclaimed"]
        assert "sec1" in result["claimed"]
        assert "sec2" in result["contested"]
        assert "sec1" in result["your_claims"]
        assert "sec2" in result["your_claims"]

class TestGetNegotiationState:
    """Tests for get_negotiation_state tool."""

    def test_all_contested(self):
        spec = Spec()
        spec.initialize_sections(["sec1"])
        spec.register_claim("triad-1", "sec1", "P1")
        spec.register_claim("triad-2", "sec1", "P2")
        toolkit = HFSToolkit(spec=spec, triad_id="triad-1")

        result = json.loads(toolkit.get_negotiation_state())

        assert result["success"] is True
        assert result["total_contested"] == 1
        assert "sec1" in result["contested_sections"]

    def test_specific_section(self):
        spec = Spec()
        spec.initialize_sections(["sec1"])
        spec.register_claim("triad-1", "sec1", "P1")
        toolkit = HFSToolkit(spec=spec, triad_id="triad-1")

        result = json.loads(toolkit.get_negotiation_state(section_id="sec1"))

        assert result["success"] is True
        assert result.get("section_id") == "sec1"

class TestGenerateCode:
    """Tests for generate_code tool."""

    def test_requires_frozen_spec(self):
        spec = Spec()
        spec.initialize_sections(["sec1"])
        spec.register_claim("triad-1", "sec1", "P1")
        toolkit = HFSToolkit(spec=spec, triad_id="triad-1")

        result = json.loads(toolkit.generate_code(section_id="sec1"))

        # Should fail - spec not frozen
        assert result["success"] is False

    def test_requires_ownership(self):
        spec = Spec()
        spec.initialize_sections(["sec1"])
        spec.register_claim("other-triad", "sec1", "P1")
        spec.freeze()
        toolkit = HFSToolkit(spec=spec, triad_id="triad-1")

        result = json.loads(toolkit.generate_code(section_id="sec1"))

        # Should fail - triad-1 doesn't own sec1
        assert result["success"] is False
```

Run tests:
```bash
cd hfs && pytest tests/test_hfs_toolkit.py -v
```
  </action>
  <verify>
```bash
cd C:/Users/jinwi/programming_files_NEW/agentive/hfs && python -m pytest tests/test_hfs_toolkit.py -v
```
  </verify>
  <done>
- All test classes pass: TestRegisterClaim, TestNegotiateResponse, TestGetCurrentClaims, TestGetNegotiationState, TestGenerateCode
- Tests verify Pydantic validation error handling with retry_allowed flag
- Tests verify Spec integration (claim registration, concession, status tracking)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Import verification:**
```bash
cd hfs && python -c "
from agno import HFSToolkit
from agno.tools import HFSToolkit, NegotiationDecision
from agno.tools.schemas import RegisterClaimInput
print('All imports OK')
"
```

2. **Tool count verification:**
```bash
cd hfs && python -c "
from agno import HFSToolkit
from core.spec import Spec
toolkit = HFSToolkit(Spec(), 'test')
assert len(toolkit.functions) == 5, f'Expected 5 tools, got {len(toolkit.functions)}'
print('5 tools registered')
"
```

3. **Full test suite:**
```bash
cd hfs && pytest tests/test_hfs_toolkit.py -v --tb=short
```
</verification>

<success_criteria>
- [ ] hfs/agno/tools/ directory exists with __init__.py, schemas.py, errors.py, toolkit.py
- [ ] HFSToolkit class with 5 methods (register_claim, negotiate_response, generate_code, get_current_claims, get_negotiation_state)
- [ ] Each tool validates inputs with Pydantic and returns JSON strings
- [ ] ValidationError returns retry_allowed: true with hints
- [ ] RuntimeError returns retry_allowed: false
- [ ] HFSToolkit exported from hfs.agno
- [ ] All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-agno-tools/02-01-SUMMARY.md`
</output>
