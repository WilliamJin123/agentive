---
phase: 12-user-experience
plan: 03
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - hfs/tui/widgets/vim_input.py
  - hfs/tui/widgets/__init__.py
  - hfs/tui/widgets/status_bar.py
  - hfs/tui/screens/chat.py
autonomous: true

must_haves:
  truths:
    - "User in vim mode cannot type until pressing i/a/A/I/o"
    - "User in vim mode can navigate with h/j/k/l in NORMAL mode"
    - "User sees NORMAL or INSERT indicator in status bar"
    - "Pressing Escape returns to NORMAL mode"
    - "Vim mode activates when keybinding_mode: vim in config"
  artifacts:
    - path: "hfs/tui/widgets/vim_input.py"
      provides: "VimChatInput with modal editing"
      contains: "class VimChatInput"
    - path: "hfs/tui/widgets/status_bar.py"
      provides: "Vim mode indicator"
      contains: "vim_mode"
  key_links:
    - from: "hfs/tui/screens/chat.py"
      to: "hfs/tui/widgets/vim_input.py"
      via: "conditional import based on keybinding_mode"
      pattern: "VimChatInput|ChatInput"
    - from: "hfs/tui/widgets/vim_input.py"
      to: "hfs/tui/widgets/status_bar.py"
      via: "ModeChanged message updates status bar"
      pattern: "ModeChanged"
---

<objective>
Implement vim-style modal editing for the chat input with NORMAL/INSERT modes and status bar indicator.

Purpose: Users who prefer vim keybindings can opt-in via config. Vim mode provides modal editing: NORMAL mode for navigation (h/j/k/l), INSERT mode for typing. Status bar shows current mode.

Output: VimChatInput widget with modal state machine, vim mode indicator in status bar, conditional widget selection based on config.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-user-experience/12-CONTEXT.md
@.planning/phases/12-user-experience/12-RESEARCH.md
@.planning/phases/12-user-experience/12-01-SUMMARY.md

# Config module from plan 01
@hfs/config/loader.py
@hfs/config/models.py

# Existing ChatInput to extend for vim mode
@hfs/tui/widgets/chat_input.py

# Status bar for vim mode indicator
@hfs/tui/widgets/status_bar.py

# ChatScreen where conditional widget selection happens
@hfs/tui/screens/chat.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement VimChatInput with modal editing</name>
  <files>
    hfs/tui/widgets/vim_input.py
    hfs/tui/widgets/__init__.py
  </files>
  <action>
Create VimChatInput widget that extends ChatInput with vim-style modal editing.

**hfs/tui/widgets/vim_input.py:**

1. Create VimMode enum: NORMAL, INSERT (skip VISUAL for now - complexity)

2. Create VimChatInput(ChatInput) with:
   - `_mode: VimMode = VimMode.NORMAL` (start in NORMAL per vim convention)
   - `ModeChanged(Message)` - posted when mode changes, includes new mode

3. Override `on_key()` to dispatch based on mode:
   - In NORMAL mode: intercept all keys, handle vim commands
   - In INSERT mode: pass most keys through, intercept Escape

4. NORMAL mode key handlers (subset per RESEARCH.md):
   - Movement: h (left), j (down), k (up), l (right), w (word right), b (word back), 0 (line start), $ (line end)
   - Mode switch: i (insert at cursor), a (insert after cursor), A (insert at line end), I (insert at line start), o (open line below)
   - Editing: x (delete char), dd (delete line), D (delete to end)
   - Use TextArea's cursor methods: action_cursor_left(), action_cursor_right(), etc.

5. INSERT mode:
   - Escape -> return to NORMAL mode (move cursor left 1 char if not at line start per vim)
   - All other keys: call super().on_key(event) to use ChatInput's normal handling

6. Post ModeChanged message when mode changes so status bar can update

**Key vim behavior from RESEARCH.md:**
- Escape in INSERT moves cursor left 1 char (unless at line start)
- Start in NORMAL mode (user must press i to type)
- Block cursor visual in NORMAL, line cursor in INSERT (CSS if possible)

**hfs/tui/widgets/__init__.py:**
Add VimChatInput to exports.

**Implementation pattern:**
```python
from enum import Enum, auto
from textual.events import Key
from textual.message import Message

from .chat_input import ChatInput

class VimMode(Enum):
    NORMAL = auto()
    INSERT = auto()

class VimChatInput(ChatInput):
    """ChatInput with vim-style modal editing."""

    class ModeChanged(Message):
        def __init__(self, mode: VimMode) -> None:
            super().__init__()
            self.mode = mode

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self._mode = VimMode.NORMAL

    @property
    def mode(self) -> VimMode:
        return self._mode

    def _set_mode(self, mode: VimMode) -> None:
        if mode != self._mode:
            self._mode = mode
            self.post_message(self.ModeChanged(mode))

    def on_key(self, event: Key) -> None:
        if self._mode == VimMode.NORMAL:
            self._handle_normal_mode(event)
        else:
            self._handle_insert_mode(event)

    def _handle_normal_mode(self, event: Key) -> None:
        event.prevent_default()
        key = event.key

        # Mode switches
        if key == "i":
            self._set_mode(VimMode.INSERT)
        elif key == "a":
            self.action_cursor_right()
            self._set_mode(VimMode.INSERT)
        elif key == "A":
            self.action_cursor_line_end()
            self._set_mode(VimMode.INSERT)
        elif key == "I":
            self.action_cursor_line_start()
            self._set_mode(VimMode.INSERT)
        # Movement
        elif key == "h":
            self.action_cursor_left()
        elif key == "l":
            self.action_cursor_right()
        elif key == "j":
            self.action_cursor_down()
        elif key == "k":
            self.action_cursor_up()
        elif key == "0":
            self.action_cursor_line_start()
        elif key == "dollar":  # $
            self.action_cursor_line_end()
        elif key == "w":
            self.action_cursor_word_right()
        elif key == "b":
            self.action_cursor_word_left()
        # Editing
        elif key == "x":
            self.action_delete_right()
        elif key == "D":
            self.action_delete_to_end_of_line()
        # dd requires state tracking (omit for simplicity)

    def _handle_insert_mode(self, event: Key) -> None:
        if event.key == "escape":
            event.prevent_default()
            self._set_mode(VimMode.NORMAL)
            # Move cursor left (vim behavior)
            self.action_cursor_left()
        else:
            # Pass through to ChatInput's on_key
            super().on_key(event)
```
  </action>
  <verify>
    Create test script:
    ```python
    from hfs.tui.widgets import VimChatInput
    from hfs.tui.widgets.vim_input import VimMode

    # Test class exists and has mode
    vim_input = VimChatInput()
    assert vim_input._mode == VimMode.NORMAL
    ```
    Test in TUI (after wiring in Task 3):
    - Start HFS with vim mode config
    - Verify can't type in NORMAL mode
    - Press i, type text, press Escape
    - Verify cursor moves left on Escape
    - Press h/j/k/l to navigate
  </verify>
  <done>
    - VimChatInput starts in NORMAL mode
    - h/j/k/l navigation works in NORMAL mode
    - i/a/A/I enter INSERT mode
    - Escape returns to NORMAL mode
    - ModeChanged message posted on mode transitions
  </done>
</task>

<task type="auto">
  <name>Task 2: Add vim mode indicator to status bar</name>
  <files>
    hfs/tui/widgets/status_bar.py
  </files>
  <action>
**hfs/tui/widgets/status_bar.py:**

1. Add reactive attribute: `vim_mode: reactive[str] = reactive("")`
   - Empty string when not in vim mode
   - "NORMAL" or "INSERT" when in vim mode

2. Add status section in compose() for vim mode indicator:
   - Position: after model label, before tokens
   - Only visible when vim_mode is not empty
   - Style: bold, distinct color (yellow for NORMAL, green for INSERT)

3. Add watcher `watch_vim_mode(new_value: str)` to trigger refresh if needed

4. Add method `set_vim_mode(mode: str)` for external updates (or use reactive directly)

**CSS for vim mode indicator:**
```css
.vim-mode {
    background: $warning;
    color: $background;
    padding: 0 1;
    text-style: bold;
}

.vim-mode.insert {
    background: $success;
}
```

**compose() update:**
```python
def compose(self) -> ComposeResult:
    with Horizontal():
        yield Static(self.model, id="model-label")
        if self.vim_mode:
            yield Static(self.vim_mode, classes="vim-mode")
        yield Static(f"Tokens: {self.tokens}", id="token-count")
        # ... rest
```

**Note:** If reactive doesn't auto-update compose, may need to use a Label widget and update its content in watch_vim_mode.
  </action>
  <verify>
    Will be testable after Task 3 wiring:
    1. Set keybinding_mode: vim in config
    2. Start HFS
    3. Status bar should show "NORMAL"
    4. Press i - status bar should show "INSERT"
    5. Press Escape - status bar should show "NORMAL"
    6. With standard mode config, no vim indicator shown
  </verify>
  <done>
    - Status bar has vim_mode reactive attribute
    - Vim mode indicator shows NORMAL/INSERT when in vim mode
    - Indicator styled distinctively (yellow NORMAL, green INSERT)
    - No indicator when using standard keybinding mode
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire vim mode to ChatScreen based on config</name>
  <files>
    hfs/tui/screens/chat.py
  </files>
  <action>
**In hfs/tui/screens/chat.py:**

1. Import VimChatInput conditionally or use factory pattern:
   ```python
   from ..widgets import ChatInput, VimChatInput
   ```

2. In compose() or on_mount(), check user config keybinding_mode:
   ```python
   def compose(self) -> ComposeResult:
       yield MessageList(id="messages")
       with Container(id="input-container"):
           yield PulsingDot(id="spinner")

           # Select input widget based on keybinding mode
           config = self.app.get_user_config()
           if config.keybinding_mode == "vim":
               yield VimChatInput(id="input")
           else:
               yield ChatInput(id="input")

       yield HFSStatusBar(id="status-bar")
   ```

3. Add handler for VimChatInput.ModeChanged message:
   ```python
   def on_vim_chat_input_mode_changed(self, event: VimChatInput.ModeChanged) -> None:
       status_bar = self.query_one("#status-bar", HFSStatusBar)
       status_bar.vim_mode = event.mode.name  # "NORMAL" or "INSERT"
   ```

4. Initialize vim mode indicator on mount if using vim mode:
   ```python
   async def on_mount(self) -> None:
       input_widget = self.query_one("#input")
       input_widget.focus()

       # Set initial vim mode indicator
       if hasattr(input_widget, 'mode'):
           status_bar = self.query_one("#status-bar", HFSStatusBar)
           status_bar.vim_mode = input_widget.mode.name
   ```

5. Update /help to mention vim mode availability:
   ```
   **Vim Mode**
   Set `keybinding_mode: vim` in config for modal editing.
   - NORMAL mode: h/j/k/l navigation, i/a to insert
   - INSERT mode: Type normally, Escape to exit
   ```
  </action>
  <verify>
    1. Set keybinding_mode: standard in config -> launches with ChatInput, no vim indicator
    2. Set keybinding_mode: vim in config -> launches with VimChatInput
    3. In vim mode: can't type without pressing i first
    4. Status bar shows current mode
    5. Mode changes update status bar in real-time
  </verify>
  <done>
    - ChatScreen uses VimChatInput when config.keybinding_mode == "vim"
    - ModeChanged handler updates status bar
    - Standard mode uses regular ChatInput (no vim indicator)
    - /help documents vim mode availability
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Standard mode test (default):**
   ```bash
   # Ensure no keybinding_mode in config or set to "standard"
   python -m hfs.tui

   # Should be able to type immediately
   # No vim indicator in status bar
   ```

2. **Vim mode test:**
   ```bash
   # Set vim mode
   echo "keybinding_mode: vim" > ~/.hfs/config.yaml

   # Start HFS
   python -m hfs.tui

   # Should start in NORMAL mode (can't type)
   # Status bar shows "NORMAL"
   # Press i -> INSERT mode (can type)
   # Status bar shows "INSERT"
   # Type "hello"
   # Press Escape -> NORMAL mode
   # Press h/l to move cursor
   ```

3. **Mode transitions:**
   ```bash
   # In vim mode:
   # Press a -> INSERT after cursor
   # Press A -> INSERT at line end
   # Press I -> INSERT at line start
   # All should update status bar
   ```
</verification>

<success_criteria>
- [ ] VimChatInput exists with NORMAL/INSERT modes
- [ ] h/j/k/l navigation works in NORMAL mode
- [ ] i/a/A/I enter INSERT mode, Escape exits
- [ ] Status bar shows NORMAL/INSERT in vim mode
- [ ] ChatScreen uses VimChatInput when keybinding_mode: vim
- [ ] Standard mode shows no vim indicator
- [ ] Mode indicator updates in real-time
</success_criteria>

<output>
After completion, create `.planning/phases/12-user-experience/12-03-SUMMARY.md`
</output>
