---
phase: 12-user-experience
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - hfs/tui/widgets/completers.py
  - hfs/tui/widgets/__init__.py
  - hfs/tui/screens/chat.py
autonomous: true

must_haves:
  truths:
    - "User sees command suggestions when typing / in input"
    - "User can tab-complete to select a command"
    - "User can tab-complete file paths after certain commands"
    - "Standard/Emacs keybinding mode provides Ctrl+A/E/K navigation (built-in)"
    - "Output mode preference is stored and reported in /config"
  artifacts:
    - path: "hfs/tui/widgets/completers.py"
      provides: "Command and path tab completion"
      contains: "class CommandCompleter"
    - path: "hfs/tui/screens/chat.py"
      provides: "Completion integration"
      contains: "CommandCompleter"
  key_links:
    - from: "hfs/tui/screens/chat.py"
      to: "hfs/tui/widgets/completers.py"
      via: "CommandCompleter import and usage"
      pattern: "from.*completers import"
---

<objective>
Implement tab completion for slash commands and file paths, and document the standard/Emacs keybinding mode that TextArea provides by default.

Purpose: Users can discover commands via tab completion, complete file paths for commands that accept them, and use familiar Emacs-style shortcuts (Ctrl+A/E/K) in standard mode. Output mode preference stored for future widget visibility control.

Output: CommandCompleter widget with contextual completion (commands vs paths), Emacs mode documented as standard mode, output_mode stored in config.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-user-experience/12-CONTEXT.md
@.planning/phases/12-user-experience/12-RESEARCH.md
@.planning/phases/12-user-experience/12-01-SUMMARY.md

# Config module from plan 01
@hfs/config/loader.py
@hfs/config/models.py

# Existing ChatInput (already has Emacs-style keybindings via TextArea)
@hfs/tui/widgets/chat_input.py

# ChatScreen where completion will be integrated
@hfs/tui/screens/chat.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement command tab completion</name>
  <files>
    hfs/tui/widgets/completers.py
    hfs/tui/widgets/__init__.py
  </files>
  <action>
Create tab completion for slash commands using textual-autocomplete if it works with TextArea, or a fallback approach if not.

**First, test textual-autocomplete compatibility:**
```python
# Quick test in Python REPL
from textual_autocomplete import AutoComplete
from textual.widgets import TextArea
# Check if AutoComplete target can be TextArea
```

**If textual-autocomplete works with TextArea:**

**hfs/tui/widgets/completers.py:**
```python
from textual_autocomplete import AutoComplete, DropdownItem

class CommandCompleter(AutoComplete):
    """Autocomplete for slash commands."""

    COMMANDS = [
        DropdownItem("/help", left_meta="?"),
        DropdownItem("/clear", left_meta="X"),
        DropdownItem("/config", left_meta="C"),
        DropdownItem("/config set output_mode compact"),
        DropdownItem("/config set output_mode verbose"),
        DropdownItem("/config set keybinding_mode vim"),
        DropdownItem("/config set keybinding_mode standard"),
        DropdownItem("/mode compact", left_meta="M"),
        DropdownItem("/mode verbose", left_meta="M"),
        DropdownItem("/inspect", left_meta="I"),
        DropdownItem("/exit", left_meta="Q"),
    ]

    def get_candidates(self, state):
        text = state.text
        if text.startswith("/"):
            return [c for c in self.COMMANDS if c.main.lower().startswith(text.lower())]
        return []
```

**If textual-autocomplete does NOT work with TextArea (fallback):**

Create a simpler Suggester-based approach or popup-based completion:
```python
from textual.suggester import Suggester

class CommandSuggester(Suggester):
    """Inline suggestions for slash commands."""

    COMMANDS = ["/help", "/clear", "/config", "/mode compact", "/mode verbose", "/inspect", "/exit"]

    async def get_suggestion(self, value: str) -> str | None:
        if value.startswith("/"):
            for cmd in self.COMMANDS:
                if cmd.startswith(value) and cmd != value:
                    return cmd
        return None
```

Note: Suggester provides inline ghost text (Tab to accept), not dropdown. This is acceptable fallback.

**hfs/tui/widgets/__init__.py:**
Add CommandCompleter (or CommandSuggester) export.

**Install dependency if using textual-autocomplete:**
Add `textual-autocomplete>=3.0` to pyproject.toml dependencies.
  </action>
  <verify>
    1. Test textual-autocomplete compatibility first:
       ```python
       python -c "from textual_autocomplete import AutoComplete; print('OK')"
       ```
    2. Start HFS
    3. Type "/" - should see completion suggestions (dropdown or inline ghost text)
    4. Type "/he" - should filter to "/help"
    5. Press Tab to accept completion
  </verify>
  <done>
    - Command completion available when typing slash commands
    - Tab key accepts completion
    - All current slash commands included in suggestions
  </done>
</task>

<task type="auto">
  <name>Task 2: Add file path completion for commands</name>
  <files>
    hfs/tui/widgets/completers.py
  </files>
  <action>
Extend the completer to support file path completion after certain commands.

**Context detection:**
File path completion should trigger when:
- Input matches pattern like `/somecommand path/to/` (command + space + path-like text)
- Current text after last space looks like a path (contains `/` or `\` or starts with `.`)

**Implementation:**

Add to CommandCompleter or create PathCompleter:
```python
import os
from pathlib import Path

def get_path_completions(partial_path: str) -> list[DropdownItem]:
    """Get file/directory completions for partial path."""
    try:
        # Handle relative and absolute paths
        if not partial_path:
            base = Path.cwd()
            prefix = ""
        else:
            path = Path(partial_path)
            if partial_path.endswith(("/", "\\")):
                base = path
                prefix = partial_path
            else:
                base = path.parent
                prefix = str(path.parent) + "/" if str(path.parent) != "." else ""

        if not base.exists():
            return []

        completions = []
        for item in base.iterdir():
            name = item.name
            if item.is_dir():
                name += "/"
            full_path = prefix + name
            completions.append(DropdownItem(full_path, left_meta="D" if item.is_dir() else "F"))

        return sorted(completions, key=lambda x: x.main)
    except Exception:
        return []

class CommandCompleter(AutoComplete):
    # ... existing COMMANDS ...

    def get_candidates(self, state):
        text = state.text

        # Check if we're completing a file path (after command)
        if " " in text:
            parts = text.split(" ", 1)
            command = parts[0]
            arg = parts[1] if len(parts) > 1 else ""

            # Commands that accept file paths (future: /load, /export, etc.)
            # For now, complete paths after any command with a space
            if arg or text.endswith(" "):
                path_completions = get_path_completions(arg)
                if path_completions:
                    # Prepend the command to each completion
                    return [
                        DropdownItem(f"{command} {c.main}", left_meta=c.left_meta)
                        for c in path_completions
                    ]

        # Fall back to command completion
        if text.startswith("/"):
            return [c for c in self.COMMANDS if c.main.lower().startswith(text.lower())]
        return []
```

**Note:** If using fallback Suggester approach, file path completion may need to be simpler or deferred.
  </action>
  <verify>
    1. Start HFS
    2. Type "/config " (with trailing space)
    3. Type "./" - should show files in current directory
    4. Type "../" - should show files in parent directory
    5. Tab to accept a file path
  </verify>
  <done>
    - File paths complete after commands
    - Directories show with trailing /
    - Both relative and absolute paths work
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire completion to ChatScreen and document keybinding modes</name>
  <files>
    hfs/tui/screens/chat.py
  </files>
  <action>
**Wire completion:**

1. Import CommandCompleter from widgets
2. In compose(), add completion widget:
   - If using AutoComplete: `yield CommandCompleter(target=self.query_one("#input"))`
   - If using Suggester: Pass to ChatInput: `ChatInput(suggester=CommandSuggester())`
3. Test that Tab key triggers completion (may need binding override)

**Document keybinding modes:**

Textual's TextArea (which ChatInput extends) already provides Emacs-style keybindings by default:
- Ctrl+A: Move to beginning of line
- Ctrl+E: Move to end of line
- Ctrl+K: Delete to end of line
- Ctrl+U: Delete to beginning of line
- Ctrl+W: Delete word before cursor

This means "standard" mode = "emacs" mode. They are the same.

Update /help to document available shortcuts:

```python
help_text = """**Available Commands**

| Command | Description |
|---------|-------------|
| `/help` | Show this help message |
| `/clear` | Clear all messages |
| `/config` | View current configuration |
| `/config set key value` | Change a setting |
| `/mode compact\|verbose` | Switch output mode |
| `/inspect` | Open inspection mode |
| `/exit` | Exit the application |

**Input Tips**
- Press **Enter** to send a message
- Press **Shift+Enter** to insert a new line
- Press **Tab** to complete commands
- Press **Up/Down** to navigate history
- Press **Ctrl+R** to search history

**Keybindings (Standard/Emacs mode)**
- **Ctrl+A**: Move to beginning of line
- **Ctrl+E**: Move to end of line
- **Ctrl+K**: Delete to end of line
"""
```

**Output mode (deferred visibility):**

Note: The MODE-01/MODE-02 requirements about compact/verbose affecting widget visibility is deferred. Agent widgets (AgentTreeWidget, NegotiationPanel) exist in InspectionScreen, not ChatScreen. Until we add them to ChatScreen or create a split layout, the output_mode setting is stored as preference only.

Add comment in ChatScreen documenting this:
```python
# TODO: Wire output_mode to widget visibility when agent widgets added to ChatScreen
# Currently output_mode is stored as preference but has no visual effect
```
  </action>
  <verify>
    1. Start HFS
    2. `/help` should show updated help with keybindings section
    3. Test Ctrl+A, Ctrl+E, Ctrl+K work (these are built into TextArea)
    4. Tab completion should work for commands
    5. `/config` should show keybinding_mode: standard (or emacs - treat as equivalent)
  </verify>
  <done>
    - CommandCompleter wired to ChatScreen
    - /help documents standard/Emacs keybindings
    - Tab completion works for commands
    - Output mode stored in config (visibility deferred until agent widgets in ChatScreen)
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Tab completion test:**
   ```bash
   python -m hfs.tui

   # Type "/" -> suggestions appear
   # Type "/he" -> filters to /help
   # Press Tab -> completes to /help
   ```

2. **File path completion test:**
   ```bash
   python -m hfs.tui

   # Type "/config ./" -> shows current directory files
   # Tab to complete a file
   ```

3. **Keybindings test:**
   ```bash
   python -m hfs.tui

   # Type "hello world"
   # Ctrl+A -> cursor moves to start
   # Ctrl+E -> cursor moves to end
   # Ctrl+K -> deletes to end
   ```

4. **Config verification:**
   ```bash
   python -m hfs.tui

   /config
   # Should show keybinding_mode: standard (equivalent to emacs)
   ```
</verification>

<success_criteria>
- [ ] Tab completion shows slash commands when typing /
- [ ] Tab accepts completion selection
- [ ] File path completion works after commands
- [ ] Standard mode Emacs shortcuts work (Ctrl+A/E/K)
- [ ] /help documents available keybindings
- [ ] keybinding_mode: standard recognized as Emacs-compatible
- [ ] output_mode stored in config (visibility deferred)
</success_criteria>

<output>
After completion, create `.planning/phases/12-user-experience/12-02-SUMMARY.md`
</output>
