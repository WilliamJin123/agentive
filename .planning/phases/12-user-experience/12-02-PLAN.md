---
phase: 12-user-experience
plan: 02
type: execute
wave: 2
depends_on: ["12-01"]
files_modified:
  - hfs/tui/widgets/vim_input.py
  - hfs/tui/widgets/completers.py
  - hfs/tui/widgets/__init__.py
  - hfs/tui/widgets/status_bar.py
  - hfs/tui/screens/chat.py
  - hfs/tui/app.py
autonomous: true

must_haves:
  truths:
    - "Compact mode hides agent tree and negotiation panel"
    - "Verbose mode shows full agent activity"
    - "Output mode toggles via /mode command"
    - "Vim mode provides h/j/k/l navigation in NORMAL mode"
    - "Vim mode status indicator shows NORMAL/INSERT in status bar"
    - "Tab completion shows dropdown for slash commands starting with /"
    - "Keybinding mode is read from config at startup"
  artifacts:
    - path: "hfs/tui/widgets/vim_input.py"
      provides: "VimChatInput with modal editing"
      contains: "class VimChatInput"
    - path: "hfs/tui/widgets/completers.py"
      provides: "Command tab completion"
      contains: "class CommandCompleter"
    - path: "hfs/tui/widgets/status_bar.py"
      provides: "Vim mode indicator"
      contains: "vim_mode"
  key_links:
    - from: "hfs/tui/screens/chat.py"
      to: "hfs/tui/widgets/vim_input.py"
      via: "conditional import based on keybinding_mode"
      pattern: "VimChatInput|ChatInput"
    - from: "hfs/tui/widgets/vim_input.py"
      to: "hfs/tui/widgets/status_bar.py"
      via: "ModeChanged message updates status bar"
      pattern: "ModeChanged"
---

<objective>
Implement output mode toggling (compact/verbose) and input keybinding modes (vim/emacs/standard) with tab completion for slash commands.

Purpose: Users can toggle between compact mode (minimal output, final responses only) and verbose mode (full agent activity). Users can opt into vim-style modal editing. Tab completion helps discover available commands.

Output: VimChatInput widget with modal state machine, CommandCompleter for tab completion, output mode toggle affecting widget visibility.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-user-experience/12-CONTEXT.md
@.planning/phases/12-user-experience/12-RESEARCH.md

# Config module from plan 01
@hfs/config/loader.py
@hfs/config/models.py

# Existing ChatInput to extend for vim mode
@hfs/tui/widgets/chat_input.py

# Status bar for vim mode indicator
@hfs/tui/widgets/status_bar.py

# ChatScreen where mode affects visibility
@hfs/tui/screens/chat.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement VimChatInput with modal editing</name>
  <files>
    hfs/tui/widgets/vim_input.py
    hfs/tui/widgets/__init__.py
  </files>
  <action>
Create VimChatInput widget that extends ChatInput with vim-style modal editing.

**hfs/tui/widgets/vim_input.py:**

1. Create VimMode enum: NORMAL, INSERT (skip VISUAL for now - complexity)

2. Create VimChatInput(ChatInput) with:
   - `_mode: VimMode = VimMode.NORMAL` (start in NORMAL per vim convention)
   - `ModeChanged(Message)` - posted when mode changes, includes new mode

3. Override `on_key()` to dispatch based on mode:
   - In NORMAL mode: intercept all keys, handle vim commands
   - In INSERT mode: pass most keys through, intercept Escape

4. NORMAL mode key handlers (subset per RESEARCH.md):
   - Movement: h (left), j (down), k (up), l (right), w (word right), b (word back), 0 (line start), $ (line end)
   - Mode switch: i (insert at cursor), a (insert after cursor), A (insert at line end), I (insert at line start), o (open line below)
   - Editing: x (delete char), dd (delete line), D (delete to end)
   - Use TextArea's cursor methods: action_cursor_left(), action_cursor_right(), etc.

5. INSERT mode:
   - Escape -> return to NORMAL mode (move cursor left 1 char if not at line start per vim)
   - All other keys pass through to ChatInput/TextArea default handling

6. Post ModeChanged message when mode changes so status bar can update

**Key vim behavior from RESEARCH.md:**
- Escape in INSERT moves cursor left 1 char (unless at line start)
- Start in NORMAL mode (user must press i to type)
- Block cursor visual in NORMAL, line cursor in INSERT (CSS if possible)

**hfs/tui/widgets/__init__.py:**
Add VimChatInput to exports.
  </action>
  <verify>
    Create test script:
    ```python
    from hfs.tui.widgets import VimChatInput
    from hfs.tui.widgets.vim_input import VimMode

    # Test class exists and has mode
    vim_input = VimChatInput()
    assert vim_input._mode == VimMode.NORMAL
    ```
    Test in TUI (after wiring in Task 3):
    - Start HFS with vim mode config
    - Verify can't type in NORMAL mode
    - Press i, type text, press Escape
    - Verify cursor moves left on Escape
    - Press h/j/k/l to navigate
  </verify>
  <done>
    - VimChatInput starts in NORMAL mode
    - h/j/k/l navigation works in NORMAL mode
    - i/a/A/I enter INSERT mode
    - Escape returns to NORMAL mode
    - ModeChanged message posted on mode transitions
  </done>
</task>

<task type="auto">
  <name>Task 2: Add vim mode indicator to status bar and wire keybinding modes</name>
  <files>
    hfs/tui/widgets/status_bar.py
    hfs/tui/screens/chat.py
    hfs/tui/app.py
  </files>
  <action>
**hfs/tui/widgets/status_bar.py:**

1. Add reactive attribute: `vim_mode: reactive[str] = reactive("")`
   - Empty string when not in vim mode
   - "NORMAL" or "INSERT" when in vim mode

2. Add status section in compose() for vim mode indicator:
   - Between model and spacer
   - Only visible when vim_mode is not empty
   - Style: bold, distinct color (e.g., yellow for NORMAL, green for INSERT)

3. Add watcher `watch_vim_mode(value: str)` to update display

4. Add method `set_vim_mode(mode: str)` for external updates

**hfs/tui/screens/chat.py:**

1. In compose() or on_mount(), check user config keybinding_mode:
   - If "vim": yield VimChatInput instead of ChatInput
   - If "standard" or "emacs": yield ChatInput (standard behavior)

2. Add handler for VimChatInput.ModeChanged message:
   ```python
   def on_vim_chat_input_mode_changed(self, event: VimChatInput.ModeChanged) -> None:
       status_bar = self.query_one("#status-bar", HFSStatusBar)
       status_bar.vim_mode = event.mode.name  # "NORMAL" or "INSERT"
   ```

3. Get keybinding_mode from app's user config:
   ```python
   config = self.app.get_user_config()
   if config.keybinding_mode == "vim":
       yield VimChatInput(id="input")
   else:
       yield ChatInput(id="input")
   ```

**hfs/tui/app.py:**
Ensure get_user_config() is available (from plan 01).
  </action>
  <verify>
    1. Set keybinding_mode: vim in ~/.hfs/config.yaml
    2. Start HFS
    3. Status bar should show "NORMAL"
    4. Press i - status bar should show "INSERT"
    5. Press Escape - status bar should show "NORMAL"
    6. With standard mode config, no vim indicator shown
  </verify>
  <done>
    - Status bar shows NORMAL/INSERT when vim mode active
    - ChatScreen uses VimChatInput when config.keybinding_mode == "vim"
    - Mode indicator updates in real-time on mode changes
    - No vim indicator shown in standard/emacs modes
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement output mode toggling and tab completion</name>
  <files>
    hfs/tui/screens/chat.py
    hfs/tui/widgets/completers.py
    hfs/tui/widgets/__init__.py
  </files>
  <action>
**Output Mode Toggle:**

Per CONTEXT.md: Compact mode hides agent activity only (agent tree, negotiation panel), shows final responses and status bar.

1. In ChatScreen, add reactive attribute or method to track output_mode
2. Add CSS classes or display toggling for compact vs verbose:
   - Compact: hide AgentTreeWidget, NegotiationPanel (if present in layout)
   - Verbose: show all widgets
3. When /mode command is executed (from plan 01), call method to apply visibility changes
4. Read initial mode from config and apply on mount

Since ChatScreen currently doesn't include AgentTreeWidget/NegotiationPanel in main chat (they're in inspection mode), the compact/verbose toggle for now can be a stored preference that will affect future widget additions. Add a `_output_mode` attribute and methods to get/set it.

**Tab Completion:**

Per RESEARCH.md, use textual-autocomplete library.

**hfs/tui/widgets/completers.py:**
```python
from textual_autocomplete import AutoComplete, DropdownItem

class CommandCompleter(AutoComplete):
    """Autocomplete for slash commands."""

    COMMANDS = [
        DropdownItem("/help", left_meta="?"),
        DropdownItem("/clear", left_meta="X"),
        DropdownItem("/config", left_meta="C"),
        DropdownItem("/config set output_mode compact"),
        DropdownItem("/config set output_mode verbose"),
        DropdownItem("/config set keybinding_mode vim"),
        DropdownItem("/mode compact", left_meta="M"),
        DropdownItem("/mode verbose", left_meta="M"),
        DropdownItem("/inspect", left_meta="I"),
        DropdownItem("/exit", left_meta="Q"),
    ]

    def get_candidates(self, state):
        text = state.text
        if text.startswith("/"):
            return [c for c in self.COMMANDS if c.main.lower().startswith(text.lower())]
        return []
```

**Integration in ChatScreen:**
1. Import CommandCompleter
2. In compose(), yield CommandCompleter(target=input_widget) after the input widget
3. Tab key should trigger completion dropdown when text starts with /

**Note:** textual-autocomplete may need to be installed: `pip install textual-autocomplete`
Check if it works with TextArea or only Input. If only Input, may need adaptation or fallback.

**hfs/tui/widgets/__init__.py:**
Add CommandCompleter export.
  </action>
  <verify>
    1. Install textual-autocomplete: `pip install textual-autocomplete`
    2. Start HFS
    3. Type "/" - completion dropdown should appear
    4. Type "/he" - should filter to "/help"
    5. Press Tab or Enter to select
    6. /mode compact - should set output_mode to compact (verify via /config)
  </verify>
  <done>
    - Tab completion dropdown appears when typing slash commands
    - Dropdown filters as user types
    - Selection inserts command text
    - Output mode preference stored and accessible
    - /mode command updates output_mode config
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Vim mode test:**
   ```bash
   # Set vim mode
   echo "keybinding_mode: vim" > ~/.hfs/config.yaml

   # Start HFS
   python -m hfs.tui

   # Should start in NORMAL mode (can't type)
   # Press i -> INSERT mode (can type)
   # Type "hello"
   # Press Escape -> NORMAL mode
   # Press h/l to move cursor
   # Press dd to delete line
   ```

2. **Tab completion test:**
   ```bash
   python -m hfs.tui

   # Type "/" -> dropdown appears with commands
   # Type "/he" -> filters to /help
   # Tab/Enter selects
   ```

3. **Output mode test:**
   ```bash
   python -m hfs.tui

   /mode compact
   /config  # Should show output_mode: compact

   /mode verbose
   /config  # Should show output_mode: verbose
   ```

4. **Integration test:**
   - Start with vim mode
   - Status bar shows "NORMAL"
   - Use tab completion to run /mode compact
   - Config persists after restart
</verification>

<success_criteria>
- [ ] VimChatInput exists with NORMAL/INSERT modes
- [ ] h/j/k/l navigation works in NORMAL mode
- [ ] i/a/A/I enter INSERT mode, Escape exits
- [ ] Status bar shows NORMAL/INSERT in vim mode
- [ ] ChatScreen uses VimChatInput when keybinding_mode: vim
- [ ] Tab completion dropdown works for slash commands
- [ ] /mode compact|verbose changes output_mode config
- [ ] Output mode preference persists
</success_criteria>

<output>
After completion, create `.planning/phases/12-user-experience/12-02-SUMMARY.md`
</output>
