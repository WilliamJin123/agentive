---
phase: 12-user-experience
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - hfs/config/__init__.py
  - hfs/config/models.py
  - hfs/config/loader.py
  - hfs/tui/screens/chat.py
autonomous: true

must_haves:
  truths:
    - "User preferences persist after HFS restart"
    - "Project config overrides global config for same settings"
    - "Environment variables take precedence over config files"
    - "User can view all current settings via /config"
    - "User can change a setting via /config set without editing files"
    - "Invalid setting values are rejected with helpful explanation"
  artifacts:
    - path: "hfs/config/models.py"
      provides: "UserConfig Pydantic model"
      contains: "class UserConfig"
    - path: "hfs/config/loader.py"
      provides: "ConfigLoader with layered loading and writing"
      exports: ["ConfigLoader", "load_user_config"]
    - path: "hfs/tui/screens/chat.py"
      provides: "/config command handling"
      contains: "/config"
  key_links:
    - from: "hfs/tui/screens/chat.py"
      to: "hfs/config/loader.py"
      via: "ConfigLoader import and usage"
      pattern: "from hfs\\.config"
    - from: "hfs/config/loader.py"
      to: "hfs/config/models.py"
      via: "UserConfig import"
      pattern: "from .models import UserConfig"
---

<objective>
Create the configuration system for HFS user preferences with layered YAML config loading and a /config slash command for viewing and editing settings.

Purpose: Users can customize HFS behavior via config files (~/.hfs/config.yaml for global, .hfs/config.yaml for project-specific) and environment variables, with runtime viewing/editing through /config command.

Output: Working config module with UserConfig model, ConfigLoader with precedence (global -> project -> env), /config command in ChatScreen.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-user-experience/12-CONTEXT.md
@.planning/phases/12-user-experience/12-RESEARCH.md

# Existing config module for reference (HFS run config, not user prefs)
@hfs/core/config.py

# ChatScreen where /config command will be added
@hfs/tui/screens/chat.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create UserConfig model and ConfigLoader</name>
  <files>
    hfs/config/__init__.py
    hfs/config/models.py
    hfs/config/loader.py
  </files>
  <action>
Create a new hfs/config/ module for user preferences (separate from hfs/core/config.py which handles run configuration).

**hfs/config/models.py:**
Create UserConfig Pydantic model with fields:
- `output_mode: Literal["compact", "verbose"] = "verbose"` (default verbose per CONTEXT.md)
- `keybinding_mode: Literal["standard", "vim", "emacs"] = "standard"` (default standard per CONTEXT.md)
- Use `model_config = ConfigDict(extra="ignore")` to warn but not fail on unknown keys

**hfs/config/loader.py:**
Create ConfigLoader class with:
- `load() -> UserConfig`: Load config with precedence: env > project (.hfs/config.yaml) > global (~/.hfs/config.yaml) > defaults
- `save(key: str, value: Any) -> None`: Write single key update to global config (~/.hfs/config.yaml)
- `get_effective_config() -> dict`: Return merged config as dict for display, including source indicator per key
- Use `yaml.safe_load()` for reading (secure)
- Use `ruamel.yaml` for writing (preserves comments if file exists)
- Handle missing files gracefully (use defaults)
- Handle invalid YAML gracefully (log warning, use defaults)
- Environment variable mapping: HFS_OUTPUT_MODE -> output_mode, HFS_KEYBINDING_MODE -> keybinding_mode

**hfs/config/__init__.py:**
Export ConfigLoader, UserConfig, load_user_config convenience function.

Key patterns from RESEARCH.md:
- Check path.exists() before loading (don't treat missing as error)
- Use Pydantic for validation with clear error messages
- Create parent directories when writing: `path.parent.mkdir(parents=True, exist_ok=True)`
  </action>
  <verify>
    Create test file `test_config_loader.py`:
    ```python
    from hfs.config import ConfigLoader, UserConfig

    # Test defaults (no config file)
    loader = ConfigLoader()
    config = loader.load()
    assert config.output_mode == "verbose"
    assert config.keybinding_mode == "standard"

    # Test env override
    import os
    os.environ["HFS_OUTPUT_MODE"] = "compact"
    config = loader.load()
    assert config.output_mode == "compact"
    del os.environ["HFS_OUTPUT_MODE"]
    ```
    Run: `python test_config_loader.py`
  </verify>
  <done>
    - UserConfig model validates output_mode and keybinding_mode with Literal types
    - ConfigLoader.load() returns valid UserConfig with layered precedence
    - ConfigLoader.save() writes to ~/.hfs/config.yaml
    - Missing config files result in defaults, not errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add /config command to ChatScreen</name>
  <files>
    hfs/tui/screens/chat.py
  </files>
  <action>
Add /config command handling to ChatScreen:

1. Add "/config" to SLASH_COMMANDS dict mapping to "handle_config"

2. Create `handle_config()` method that:
   - Parses subcommands: `/config` (show), `/config set key value` (edit)
   - For show: Display current effective config as formatted key: value pairs
   - For set: Validate key exists, validate value is valid for that key, save via ConfigLoader
   - For invalid: Show helpful error message

3. Store ConfigLoader instance on ChatScreen (or get from app):
   - Initialize in `on_mount()` or compose
   - Use for /config show and /config set

4. Format config display nicely:
   ```
   **HFS Configuration**

   | Setting | Value | Source |
   |---------|-------|--------|
   | output_mode | verbose | default |
   | keybinding_mode | standard | ~/.hfs/config.yaml |
   ```

5. Handle /config set with validation:
   - `/config set output_mode compact` -> saves, shows confirmation
   - `/config set output_mode invalid` -> shows error: "'output_mode' must be 'compact' or 'verbose'"
   - `/config set unknown_key value` -> shows error: "Unknown setting: 'unknown_key'"

Import ConfigLoader at top of file: `from hfs.config import ConfigLoader`
  </action>
  <verify>
    Run HFS and test:
    1. `/config` - should show current settings table
    2. `/config set output_mode compact` - should confirm change
    3. `/config set output_mode invalid` - should show error
    4. Check ~/.hfs/config.yaml was created with output_mode: compact
  </verify>
  <done>
    - /config shows current effective configuration with source indicators
    - /config set key value updates and persists to ~/.hfs/config.yaml
    - Invalid values rejected with clear explanation
    - Unknown keys rejected with error message
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire config to app startup and help command</name>
  <files>
    hfs/tui/app.py
    hfs/tui/screens/chat.py
  </files>
  <action>
1. **In hfs/tui/app.py:**
   - Import ConfigLoader and UserConfig
   - Add `self._user_config: UserConfig` attribute
   - Load config in `__init__` or `on_mount`: `self._user_config = ConfigLoader().load()`
   - Add `get_user_config() -> UserConfig` method for screens to access

2. **In hfs/tui/screens/chat.py:**
   - Update show_help() to include /config in the commands table:
     ```
     | `/config` | View current configuration |
     | `/config set key value` | Change a setting |
     ```
   - Add /mode command as alias for output mode switching (per CONTEXT.md):
     - `/mode compact` -> shorthand for `/config set output_mode compact`
     - `/mode verbose` -> shorthand for `/config set output_mode verbose`
   - Add "/mode": "handle_mode" to SLASH_COMMANDS

3. **handle_mode() method:**
   - Parse argument: `/mode compact` or `/mode verbose`
   - Delegate to config set logic
   - Show confirmation message

This wires the config system into the app lifecycle so it's available to all screens.
  </action>
  <verify>
    Run HFS:
    1. `/help` should show /config and /mode commands
    2. `/mode compact` should work as shorthand
    3. Restart HFS - config should persist (output_mode stays compact)
  </verify>
  <done>
    - HFS loads user config at startup
    - /help includes /config and /mode commands
    - /mode compact|verbose works as shorthand
    - Config persists across restarts
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Config loading test:**
   ```bash
   # Create global config
   mkdir -p ~/.hfs
   echo "output_mode: compact" > ~/.hfs/config.yaml

   # Run HFS
   python -m hfs.tui
   # /config should show output_mode: compact from ~/.hfs/config.yaml
   ```

2. **Precedence test:**
   ```bash
   # Create project config
   mkdir -p .hfs
   echo "output_mode: verbose" > .hfs/config.yaml

   # Run HFS
   python -m hfs.tui
   # /config should show output_mode: verbose (project overrides global)
   ```

3. **Env override test:**
   ```bash
   HFS_OUTPUT_MODE=compact python -m hfs.tui
   # /config should show output_mode: compact (env overrides file)
   ```

4. **Persistence test:**
   ```bash
   # In HFS:
   /config set keybinding_mode vim
   /exit

   # Restart and check
   python -m hfs.tui
   /config
   # Should show keybinding_mode: vim
   ```
</verification>

<success_criteria>
- [ ] hfs/config/ module exists with models.py, loader.py, __init__.py
- [ ] UserConfig validates output_mode and keybinding_mode
- [ ] ConfigLoader loads from ~/.hfs/config.yaml and .hfs/config.yaml with precedence
- [ ] Environment variables HFS_OUTPUT_MODE and HFS_KEYBINDING_MODE override config
- [ ] /config command shows current effective configuration
- [ ] /config set key value updates and persists to ~/.hfs/config.yaml
- [ ] /mode compact|verbose works as shorthand
- [ ] Invalid values rejected with explanation
- [ ] Config persists across HFS restarts
</success_criteria>

<output>
After completion, create `.planning/phases/12-user-experience/12-01-SUMMARY.md`
</output>
