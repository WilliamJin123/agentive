---
phase: 08-event-foundation
plan: 02
type: execute
wave: 2
depends_on: ["08-01"]
files_modified:
  - hfs/events/otel_bridge.py
  - hfs/observability/tracing.py
  - hfs/observability/__init__.py
autonomous: true

must_haves:
  truths:
    - "OpenTelemetry spans automatically emit corresponding events on start and end"
    - "Only spans with configured prefixes (hfs.*, agent.*, negotiation.*) emit events"
    - "Span errors emit separate error.* events with exception details"
    - "SpanProcessor never blocks the traced operation"
  artifacts:
    - path: "hfs/events/otel_bridge.py"
      provides: "EventBridgeSpanProcessor bridging spans to events"
      exports: ["EventBridgeSpanProcessor"]
    - path: "hfs/observability/tracing.py"
      provides: "Updated setup_tracing with event bridge support"
      contains: "add_span_processor.*EventBridgeSpanProcessor"
  key_links:
    - from: "hfs/events/otel_bridge.py"
      to: "hfs/events/bus.py"
      via: "SpanProcessor emits to EventBus"
      pattern: "event_bus\\.emit"
    - from: "hfs/events/otel_bridge.py"
      to: "loop.call_soon_threadsafe"
      via: "Thread-safe async emission from sync callbacks"
      pattern: "call_soon_threadsafe"
    - from: "hfs/observability/tracing.py"
      to: "hfs/events/otel_bridge.py"
      via: "setup_tracing adds EventBridgeSpanProcessor"
      pattern: "EventBridgeSpanProcessor"
---

<objective>
Create OTel SpanProcessor that bridges OpenTelemetry spans to the HFS event bus.

Purpose: This enables automatic event emission whenever spans start/end, making the event system work transparently with existing instrumented code. UI components can subscribe to events without the core HFS code needing to emit events explicitly.

Output: EventBridgeSpanProcessor class and integration with setup_tracing().
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-event-foundation/08-CONTEXT.md
@.planning/phases/08-event-foundation/08-RESEARCH.md
@.planning/phases/08-event-foundation/08-01-SUMMARY.md
@hfs/observability/tracing.py
@hfs/events/__init__.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EventBridgeSpanProcessor</name>
  <files>hfs/events/otel_bridge.py</files>
  <action>
Create custom SpanProcessor that bridges OTel spans to HFS events following CONTEXT.md decisions and RESEARCH.md patterns:

1. Class EventBridgeSpanProcessor(SpanProcessor):
   - DEFAULT_PREFIXES = ["hfs.", "agent.", "negotiation."] (configurable per CONTEXT.md)
   - ALLOWED_ATTRIBUTES = ["agent_id", "phase_id", "triad_id", "role", "status"]

2. __init__(event_bus: EventBus, run_id: str, prefixes: Optional[list[str]], loop: Optional[asyncio.AbstractEventLoop]):
   - Store event_bus, run_id, prefixes
   - Get event loop at init time (CRITICAL per RESEARCH.md pitfall #4)
   - _span_starts: dict[int, float] for duration tracking

3. on_start(span: Span, parent_context=None) -> None:
   - Check _should_emit(span.name) - filter by prefix
   - Store start time in _span_starts by span_id
   - Extract allowed attributes from span
   - Convert span name to event_type (hfs.phase.X -> phase.started)
   - Create appropriate event using factory method
   - Emit via _emit_async() - NON-BLOCKING (use loop.call_soon_threadsafe per RESEARCH.md)

4. on_end(span: ReadableSpan) -> None:
   - Check _should_emit
   - Calculate duration_ms from stored start time
   - Create end event with duration_ms
   - Emit via _emit_async()
   - If span has error status, emit ErrorEvent separately (per CONTEXT.md)

5. Helper methods:
   - _should_emit(span_name: str) -> bool: any(span_name.startswith(p) for p in prefixes)
   - _span_to_event_type(span_name: str, is_end: bool) -> str: Extract category from name
   - _extract_attributes(span) -> dict: Get allowed attributes with hfs.* prefix
   - _create_event(event_type: str, attrs: dict) -> HFSEvent: Factory for event types
   - _emit_async(event: HFSEvent) -> None: Use loop.call_soon_threadsafe + asyncio.create_task

6. shutdown() and force_flush() methods (required by SpanProcessor interface)

CRITICAL: on_start and on_end are SYNCHRONOUS callbacks - never await or block. Always use loop.call_soon_threadsafe for async operations.
  </action>
  <verify>
Run: python -c "
from hfs.events.otel_bridge import EventBridgeSpanProcessor
from hfs.events import EventBus
import asyncio

bus = EventBus()
processor = EventBridgeSpanProcessor(bus, run_id='test-run')
print(f'Prefixes: {processor.prefixes}')
print(f'Should emit hfs.phase.deliberation: {processor._should_emit(\"hfs.phase.deliberation\")}')
print(f'Should emit random.span: {processor._should_emit(\"random.span\")}')
"
Expected: Prefixes: ['hfs.', 'agent.', 'negotiation.'], Should emit hfs.phase.deliberation: True, Should emit random.span: False
  </verify>
  <done>
EventBridgeSpanProcessor filters spans by prefix and emits events on start/end without blocking. Error spans emit separate error events. Thread-safe emission via loop.call_soon_threadsafe.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate SpanProcessor into tracing setup</name>
  <files>hfs/observability/tracing.py, hfs/observability/__init__.py, hfs/events/__init__.py</files>
  <action>
Update tracing setup to optionally add EventBridgeSpanProcessor:

**hfs/observability/tracing.py:**
1. Add optional parameters to setup_tracing():
   - event_bus: Optional[EventBus] = None
   - run_id: Optional[str] = None
   - event_prefixes: Optional[list[str]] = None

2. If event_bus is provided:
   - Import EventBridgeSpanProcessor
   - Create processor with event_bus, run_id, event_prefixes
   - Add to provider via provider.add_span_processor(event_bridge_processor)

3. Update docstring to document new parameters

4. Store event_bridge reference at module level for potential access

**hfs/observability/__init__.py:**
1. Update imports and __all__ if needed

**hfs/events/__init__.py:**
1. Add EventBridgeSpanProcessor to exports

This keeps the event bridge optional - existing code without event bus continues to work unchanged. New code can pass event_bus to enable automatic event emission from spans.
  </action>
  <verify>
Run: python -c "
import asyncio
from hfs.observability import setup_tracing, get_tracer
from hfs.events import EventBus

async def test():
    bus = EventBus()
    stream = await bus.subscribe('phase.*')

    # Setup tracing with event bridge
    setup_tracing(event_bus=bus, run_id='test-run')
    tracer = get_tracer('hfs.test')

    # Create a span - should emit events
    with tracer.start_as_current_span('hfs.phase.test') as span:
        span.set_attribute('hfs.phase_id', 'p1')
        await asyncio.sleep(0.1)  # Let event propagate

    await asyncio.sleep(0.1)  # Let end event propagate

    # Check if events were emitted
    events = []
    while not stream._sub.queue.empty():
        events.append(await stream.__anext__())

    print(f'Events received: {len(events)}')
    for e in events:
        print(f'  - {e.event_type}')

asyncio.run(test())
"
Expected: Events received: 2 (phase.started, phase.ended)
  </verify>
  <done>
setup_tracing() accepts optional event_bus parameter. When provided, EventBridgeSpanProcessor is added and spans automatically emit events. Backward compatible - existing code without event_bus unchanged.
  </done>
</task>

</tasks>

<verification>
1. SpanProcessor filters by prefix correctly
2. Start events emitted when span starts
3. End events include duration_ms
4. Error spans emit additional ErrorEvent
5. No blocking in on_start/on_end (verified by no performance degradation)
6. setup_tracing backward compatible (works without event_bus)
7. Integration test: spans -> events -> subscriber works end-to-end
</verification>

<success_criteria>
- [ ] hfs/events/otel_bridge.py exists with EventBridgeSpanProcessor
- [ ] EventBridgeSpanProcessor implements SpanProcessor interface
- [ ] Prefix filtering works (hfs.*, agent.*, negotiation.*)
- [ ] Thread-safe emission via loop.call_soon_threadsafe
- [ ] setup_tracing accepts event_bus parameter
- [ ] Backward compatible - setup_tracing() without args still works
- [ ] Integration verified: span creation emits events to subscribers
</success_criteria>

<output>
After completion, create `.planning/phases/08-event-foundation/08-02-SUMMARY.md`
</output>
