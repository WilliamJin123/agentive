---
phase: 08-event-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - hfs/events/__init__.py
  - hfs/events/models.py
  - hfs/events/bus.py
  - hfs/events/stream.py
autonomous: true

must_haves:
  truths:
    - "Event bus accepts subscriptions with wildcard patterns (agent.*, negotiation.*, *)"
    - "EventStream async generator yields events for consumption via async for"
    - "Bounded queues provide backpressure when subscribers are slow"
    - "Both persistent subscriptions and one-shot once() work"
    - "Typed Pydantic events exist for all HFS lifecycle stages"
  artifacts:
    - path: "hfs/events/models.py"
      provides: "Pydantic event models with discriminated union"
      exports: ["HFSEvent", "RunStartedEvent", "RunEndedEvent", "PhaseStartedEvent", "PhaseEndedEvent", "AgentStartedEvent", "AgentEndedEvent", "NegotiationClaimedEvent", "NegotiationContestedEvent", "NegotiationResolvedEvent", "ErrorEvent", "UsageEvent", "AnyHFSEvent"]
    - path: "hfs/events/bus.py"
      provides: "EventBus with subscribe, emit, once, unsubscribe"
      exports: ["EventBus", "Subscription"]
    - path: "hfs/events/stream.py"
      provides: "EventStream async generator"
      exports: ["EventStream"]
    - path: "hfs/events/__init__.py"
      provides: "Public module exports"
  key_links:
    - from: "hfs/events/bus.py"
      to: "hfs/events/models.py"
      via: "EventBus.emit accepts HFSEvent"
      pattern: "emit.*HFSEvent"
    - from: "hfs/events/bus.py"
      to: "hfs/events/stream.py"
      via: "subscribe returns EventStream"
      pattern: "subscribe.*EventStream"
    - from: "hfs/events/stream.py"
      to: "asyncio.Queue"
      via: "__anext__ awaits queue.get()"
      pattern: "await.*queue\\.get"
---

<objective>
Create Pydantic event models and async event bus for HFS lifecycle events.

Purpose: This is the foundation for real-time UI updates. The event bus allows Textual widgets (Phase 10+) and StateManager (Phase 9) to subscribe to HFS lifecycle events without tight coupling.

Output: hfs/events/ module with event models, EventBus class, and EventStream async generator.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-event-foundation/08-CONTEXT.md
@.planning/phases/08-event-foundation/08-RESEARCH.md
@hfs/observability/tracing.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic event models</name>
  <files>hfs/events/models.py</files>
  <action>
Create typed Pydantic event models following CONTEXT.md decisions:

1. Base class HFSEvent with:
   - timestamp: datetime (default_factory=datetime.utcnow)
   - run_id: str
   - event_type: str (discriminator field)

2. Lifecycle events (minimal payloads per CONTEXT.md - IDs only):
   - RunStartedEvent (event_type: Literal["run.started"])
   - RunEndedEvent (event_type: Literal["run.ended"], duration_ms: float)
   - PhaseStartedEvent (phase_id, phase_name)
   - PhaseEndedEvent (phase_id, phase_name, duration_ms)
   - AgentStartedEvent (agent_id, triad_id, role)
   - AgentEndedEvent (agent_id, triad_id, role, duration_ms)

3. Negotiation events:
   - NegotiationClaimedEvent (triad_id, section_name)
   - NegotiationContestedEvent (section_name, claimants: list[str])
   - NegotiationResolvedEvent (section_name, winner, resolution_type: Literal["concede", "arbiter"])

4. Error and usage events:
   - ErrorEvent (error_type, message, optional triad_id/agent_id)
   - UsageEvent (triad_id, prompt_tokens, completion_tokens, model)

5. Create AnyHFSEvent discriminated union using Annotated[Union[...], Field(discriminator="event_type")]

Follow RESEARCH.md patterns. Use Literal types for event_type to enable efficient validation.
  </action>
  <verify>
Run: python -c "from hfs.events.models import HFSEvent, AgentStartedEvent, AnyHFSEvent; e = AgentStartedEvent(run_id='r1', agent_id='a1', triad_id='t1', role='orchestrator'); print(e.event_type)"
Expected output: agent.started
  </verify>
  <done>
All 11 event classes defined with proper Literal event_type discriminators. AnyHFSEvent union validates any event type efficiently.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create EventBus and EventStream</name>
  <files>hfs/events/bus.py, hfs/events/stream.py, hfs/events/__init__.py</files>
  <action>
Create the async event bus and stream wrapper following RESEARCH.md patterns:

**hfs/events/stream.py:**
1. Subscription dataclass with:
   - pattern: str (wildcard pattern like "agent.*")
   - queue: asyncio.Queue[HFSEvent] with maxsize (default 100)
   - _cancelled: bool flag

2. EventStream class implementing async generator protocol:
   - __init__(subscription: Subscription)
   - __aiter__() -> returns self
   - __anext__() -> awaits queue.get(), raises StopAsyncIteration if cancelled
   - cancel() -> sets _cancelled = True

**hfs/events/bus.py:**
1. EventBus class with:
   - _subscriptions: list[Subscription]
   - _lock: asyncio.Lock for thread-safe subscription management

2. Methods:
   - async subscribe(pattern: str = "*", maxsize: int = 100) -> EventStream
   - async unsubscribe(stream: EventStream) -> None
   - async emit(event: HFSEvent) -> int (returns count delivered)
   - async once(pattern: str, timeout: Optional[float] = None) -> Optional[HFSEvent]

3. Use fnmatch.fnmatch() for pattern matching (per RESEARCH.md - don't hand-roll)
4. emit() uses asyncio.wait_for with 1s timeout per subscriber (drops if slow)

**hfs/events/__init__.py:**
Export public API: All event classes from models.py, EventBus, EventStream
  </action>
  <verify>
Run: python -c "
import asyncio
from hfs.events import EventBus, AgentStartedEvent

async def test():
    bus = EventBus()
    stream = await bus.subscribe('agent.*')
    event = AgentStartedEvent(run_id='r1', agent_id='a1', triad_id='t1', role='orchestrator')
    count = await bus.emit(event)
    print(f'Delivered to {count} subscriber(s)')
    received = await asyncio.wait_for(stream.__anext__(), timeout=1.0)
    print(f'Received: {received.event_type}')

asyncio.run(test())
"
Expected: Delivered to 1 subscriber(s), Received: agent.started
  </verify>
  <done>
EventBus accepts wildcard subscriptions and delivers events to matching subscribers. EventStream works as async generator. once() method supports one-shot subscriptions with timeout.
  </done>
</task>

</tasks>

<verification>
1. All event models import successfully: `from hfs.events.models import *`
2. EventBus wildcard patterns work: "agent.*" matches "agent.started" but not "run.started"
3. Backpressure works: Full queue with slow consumer doesn't block emitter
4. Cancellation works: Breaking from async for loop or calling cancel() stops iteration
5. No circular imports: `from hfs.events import EventBus, AgentStartedEvent` works
</verification>

<success_criteria>
- [ ] hfs/events/models.py exists with 11+ event classes
- [ ] hfs/events/bus.py exists with EventBus class
- [ ] hfs/events/stream.py exists with EventStream async generator
- [ ] hfs/events/__init__.py exports all public types
- [ ] Event emission to wildcard subscribers verified
- [ ] Async generator consumption verified
</success_criteria>

<output>
After completion, create `.planning/phases/08-event-foundation/08-01-SUMMARY.md`
</output>
