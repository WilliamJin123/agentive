---
phase: 10-textual-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - hfs/pyproject.toml
  - hfs/tui/__init__.py
  - hfs/tui/app.py
  - hfs/cli/main.py
autonomous: true

must_haves:
  truths:
    - "hfs command with no arguments launches Textual REPL"
    - "hfs --version still shows version"
    - "hfs --help still shows usage"
    - "Ctrl+C exits the REPL gracefully"
  artifacts:
    - path: "hfs/tui/__init__.py"
      provides: "TUI package init"
    - path: "hfs/tui/app.py"
      provides: "HFSApp class extending textual.app.App"
      min_lines: 30
    - path: "hfs/cli/main.py"
      provides: "Modified entry point launching REPL"
      contains: "HFSApp"
  key_links:
    - from: "hfs/cli/main.py"
      to: "hfs/tui/app.py"
      via: "import and instantiation"
      pattern: "from hfs\\.tui.*import.*HFSApp"
    - from: "hfs/pyproject.toml"
      to: "textual"
      via: "dependencies"
      pattern: "textual"
---

<objective>
Create the Textual app scaffold and modify the CLI entry point to launch the interactive REPL by default.

Purpose: This establishes the foundation for the rich terminal UI. When users run `hfs` without arguments, they enter an interactive chat mode instead of seeing help text.

Output: Working `hfs` command that launches a minimal Textual app; dependencies added to pyproject.toml
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-textual-core/10-CONTEXT.md
@.planning/phases/10-textual-core/10-RESEARCH.md

# Existing files to modify
@hfs/pyproject.toml
@hfs/cli/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Textual dependencies and create app scaffold</name>
  <files>
    hfs/pyproject.toml
    hfs/tui/__init__.py
    hfs/tui/app.py
  </files>
  <action>
1. Update hfs/pyproject.toml dependencies to add:
   - "textual>=0.50.0" (use stable version, not bleeding edge 7.5.0 from research - be conservative)
   - "rich>=13.0.0" (already a textual dependency but be explicit)
   - "prompt_toolkit>=3.0.40" (for command history with Ctrl+R)

2. Create hfs/tui/__init__.py with exports:
   - Export HFSApp from app module
   - Add __all__ list

3. Create hfs/tui/app.py with minimal HFSApp class:
   - Extend textual.app.App
   - Set TITLE = "HFS" and SUB_TITLE = "Hexagonal Frontend System"
   - Add BINDINGS for quit: Binding("ctrl+c", "quit", "Quit"), Binding("ctrl+q", "quit", "Quit")
   - Override compose() to yield a simple Placeholder or Static widget with welcome message
   - Include docstring explaining this is the main entry point

The app should be minimal but functional - just enough to verify the scaffold works.
Do NOT add theme, chat widgets, or complex features yet - those are Plan 02 and 03.
  </action>
  <verify>
    - `cd hfs && pip install -e .` succeeds (dependencies install)
    - `python -c "from hfs.tui import HFSApp; print('OK')"` prints OK
  </verify>
  <done>
    - pyproject.toml has textual, rich, prompt_toolkit dependencies
    - hfs/tui/ package exists with __init__.py and app.py
    - HFSApp class can be imported
  </done>
</task>

<task type="auto">
  <name>Task 2: Modify CLI to launch REPL by default</name>
  <files>
    hfs/cli/main.py
  </files>
  <action>
1. Modify the main() function in hfs/cli/main.py:
   - When args.command is None (no subcommand given), launch the Textual REPL instead of showing help
   - Import HFSApp from hfs.tui (lazy import inside the condition to avoid import overhead for other commands)
   - Call app = HFSApp() and app.run()
   - Return the app's return code (0 for normal exit)

2. Keep existing behavior intact:
   - --version still works (handled before command dispatch)
   - --help still works (argparse handles this)
   - All existing subcommands (run, validate-config, list-presets) still work

3. Handle Ctrl+C gracefully:
   - Textual handles this via the quit binding, but wrap in try/except KeyboardInterrupt as fallback
   - Exit cleanly with code 0 on interrupt

The key change is in the "if args.command is None:" block - change from showing help to launching REPL.
  </action>
  <verify>
    - `cd hfs && hfs` launches Textual app (shows TUI, Ctrl+C exits)
    - `cd hfs && hfs --version` shows version (0.1.0)
    - `cd hfs && hfs --help` shows help text
    - `cd hfs && hfs list-presets` still works
  </verify>
  <done>
    - Running `hfs` with no arguments launches Textual REPL
    - Ctrl+C exits the REPL gracefully
    - All existing CLI commands still function
  </done>
</task>

</tasks>

<verification>
All verification for this plan:
1. `pip install -e .` in hfs/ directory succeeds
2. `hfs` launches Textual app with placeholder content
3. `hfs --version` shows "hfs 0.1.0"
4. `hfs --help` shows usage information
5. `hfs list-presets` lists presets (existing functionality preserved)
6. Ctrl+C in REPL exits cleanly
</verification>

<success_criteria>
- Textual, rich, prompt_toolkit dependencies added to pyproject.toml
- HFSApp class exists and can be imported
- `hfs` command launches interactive REPL by default
- All existing CLI functionality preserved
- Clean exit on Ctrl+C
</success_criteria>

<output>
After completion, create `.planning/phases/10-textual-core/10-01-SUMMARY.md`
</output>
