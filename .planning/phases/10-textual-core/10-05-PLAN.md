---
phase: 10-textual-core
plan: 05
type: execute
wave: 1
depends_on: []
files_modified:
  - hfs/tui/widgets/chat_input.py
  - hfs/tui/screens/chat.py
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Up/down arrows navigate through message history"
    - "Ctrl+R opens fuzzy search through history"
    - "History persists across messages within session"
  artifacts:
    - path: "hfs/tui/widgets/chat_input.py"
      provides: "Arrow key and Ctrl+R bindings for history"
      contains: "action_history_up"
    - path: "hfs/tui/widgets/chat_input.py"
      provides: "History storage and navigation"
      contains: "_history"
  key_links:
    - from: "hfs/tui/widgets/chat_input.py"
      to: "history list"
      via: "up/down arrow actions"
      pattern: "action_history_(up|down)"
    - from: "hfs/tui/widgets/chat_input.py"
      to: "fuzzy search"
      via: "Ctrl+R binding"
      pattern: "ctrl\\+r.*history_search|action_history_search"
---

<objective>
Add command history navigation with arrow keys and Ctrl+R fuzzy search to ChatInput.

Purpose: Close the verification gap where ChatInput lacks history functionality. Success criteria requires "Command history works with arrow keys and Ctrl+R fuzzy search".

Output: ChatInput widget with up/down arrow history navigation and Ctrl+R fuzzy search.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/10-textual-core/10-VERIFICATION.md
@.planning/phases/10-textual-core/10-RESEARCH.md
@hfs/tui/widgets/chat_input.py
@hfs/tui/screens/chat.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add history storage and arrow key navigation</name>
  <files>hfs/tui/widgets/chat_input.py</files>
  <action>
Add history tracking and up/down arrow navigation to ChatInput:

1. Add instance variables for history:
   ```python
   def __init__(self, *args, **kwargs):
       # ... existing init
       self._history: list[str] = []
       self._history_index: int = -1  # -1 means not navigating
       self._current_input: str = ""  # Store current input when navigating
   ```

2. Add BINDINGS for up/down arrows:
   ```python
   BINDINGS = [
       Binding("enter", "submit", "Send", show=False),
       Binding("shift+enter", "newline", "New Line", show=False),
       Binding("up", "history_up", "Previous", show=False),
       Binding("down", "history_down", "Next", show=False),
       Binding("ctrl+r", "history_search", "Search History", show=False),
   ]
   ```

3. Modify action_submit to save to history:
   ```python
   def action_submit(self) -> None:
       text = self.text.strip()
       if text:
           # Save to history (avoid duplicates)
           if not self._history or self._history[-1] != text:
               self._history.append(text)
           # Reset navigation state
           self._history_index = -1
           self._current_input = ""
           self.post_message(self.Submitted(self, text))
           self.clear()
   ```

4. Implement action_history_up:
   ```python
   def action_history_up(self) -> None:
       """Navigate to previous history entry."""
       if not self._history:
           return

       # First up: save current input, go to last history item
       if self._history_index == -1:
           self._current_input = self.text
           self._history_index = len(self._history) - 1
       # Subsequent up: go to older entry if available
       elif self._history_index > 0:
           self._history_index -= 1
       else:
           return  # Already at oldest

       self.text = self._history[self._history_index]
       self.move_cursor_to_end()
   ```

5. Implement action_history_down:
   ```python
   def action_history_down(self) -> None:
       """Navigate to next history entry or back to current input."""
       if self._history_index == -1:
           return  # Not navigating

       if self._history_index < len(self._history) - 1:
           self._history_index += 1
           self.text = self._history[self._history_index]
       else:
           # Return to current input
           self._history_index = -1
           self.text = self._current_input
       self.move_cursor_to_end()
   ```

6. Add helper method:
   ```python
   def move_cursor_to_end(self) -> None:
       """Move cursor to end of text."""
       self.selection = Selection.cursor((len(self.text.split('\n')) - 1, len(self.text.split('\n')[-1])))
   ```

Note: Import Selection from textual.widgets.text_area if needed for cursor positioning.
  </action>
  <verify>
- `python -c "from hfs.tui.widgets.chat_input import ChatInput"` succeeds
- ChatInput has action_history_up and action_history_down methods
- ChatInput BINDINGS includes up and down
  </verify>
  <done>ChatInput has history storage and up/down arrow navigation</done>
</task>

<task type="auto">
  <name>Task 2: Add Ctrl+R fuzzy history search</name>
  <files>hfs/tui/widgets/chat_input.py, hfs/tui/screens/chat.py</files>
  <action>
Implement Ctrl+R fuzzy search for history:

**Option A: Simple inline search (recommended for simplicity)**

In ChatInput, implement action_history_search that:
1. Posts a message to parent requesting history search mode
2. Parent (ChatScreen) shows a search overlay/popup
3. User types search term, matching history items shown
4. Selection returns to ChatInput

**Option B: Simpler approach - cycle through matching items**

In ChatInput only:
1. On Ctrl+R, enter search mode (self._search_mode = True, self._search_term = "")
2. Subsequent keypresses build search term
3. Show matching history items that contain the search term
4. Enter selects, Escape cancels

**Implement Option B for simplicity:**

1. Add search state variables:
   ```python
   self._search_mode: bool = False
   self._search_term: str = ""
   self._search_matches: list[int] = []  # Indices into history
   self._search_match_index: int = 0
   ```

2. Implement action_history_search:
   ```python
   def action_history_search(self) -> None:
       """Start reverse history search (Ctrl+R)."""
       if not self._history:
           return

       if self._search_mode:
           # Already in search - cycle to next match
           if self._search_matches and len(self._search_matches) > 1:
               self._search_match_index = (self._search_match_index + 1) % len(self._search_matches)
               self._show_search_match()
       else:
           # Enter search mode
           self._search_mode = True
           self._search_term = ""
           self._update_search_matches()
           self._search_match_index = 0
           self._show_search_prompt()
   ```

3. Override on_key to handle search mode input:
   ```python
   def on_key(self, event: Key) -> None:
       if not self._search_mode:
           return  # Let normal handling proceed

       if event.key == "escape":
           self._exit_search_mode(restore=True)
           event.prevent_default()
       elif event.key == "enter":
           self._exit_search_mode(restore=False)
           event.prevent_default()
       elif event.key == "backspace":
           if self._search_term:
               self._search_term = self._search_term[:-1]
               self._update_search_matches()
               self._show_search_prompt()
           event.prevent_default()
       elif len(event.character or "") == 1:
           self._search_term += event.character
           self._update_search_matches()
           self._show_search_prompt()
           event.prevent_default()
   ```

4. Helper methods:
   ```python
   def _update_search_matches(self) -> None:
       """Find history entries matching search term."""
       if not self._search_term:
           self._search_matches = list(range(len(self._history)))
       else:
           term = self._search_term.lower()
           self._search_matches = [
               i for i, h in enumerate(self._history)
               if term in h.lower()
           ]
       self._search_match_index = 0

   def _show_search_prompt(self) -> None:
       """Update text to show search prompt and current match."""
       if self._search_matches:
           match = self._history[self._search_matches[self._search_match_index]]
           self.text = f"(reverse-i-search)`{self._search_term}': {match}"
       else:
           self.text = f"(reverse-i-search)`{self._search_term}': "

   def _show_search_match(self) -> None:
       """Show current search match."""
       if self._search_matches:
           match = self._history[self._search_matches[self._search_match_index]]
           self.text = f"(reverse-i-search)`{self._search_term}': {match}"

   def _exit_search_mode(self, restore: bool) -> None:
       """Exit search mode."""
       self._search_mode = False
       if restore:
           self.text = self._current_input
       elif self._search_matches:
           self.text = self._history[self._search_matches[self._search_match_index]]
       else:
           self.text = ""
       self._search_term = ""
       self._search_matches = []
   ```

5. Modify action_submit to exit search mode:
   ```python
   def action_submit(self) -> None:
       if self._search_mode:
           self._exit_search_mode(restore=False)
           return
       # ... rest of submit logic
   ```

Note: Import Key from textual.events for on_key handler.
  </action>
  <verify>
- `python -c "from hfs.tui.widgets.chat_input import ChatInput"` succeeds
- ChatInput has action_history_search method
- ChatInput has _search_mode and related attributes
  </verify>
  <done>ChatInput has Ctrl+R fuzzy search through message history</done>
</task>

</tasks>

<verification>
1. Run `hfs` and send several messages
2. Press Up arrow - should show previous message
3. Press Up again - should show older message
4. Press Down - should move forward in history
5. Press Down until back to empty/current input
6. Press Ctrl+R - should enter search mode
7. Type search term - should filter history
8. Press Ctrl+R again - should cycle through matches
9. Press Enter - should select match
10. Press Escape - should cancel search
</verification>

<success_criteria>
- Up arrow navigates to previous history entries
- Down arrow navigates to newer entries or current input
- Ctrl+R enters fuzzy search mode
- Search filters history by substring match
- Enter selects search result, Escape cancels
- History persists across messages within session
</success_criteria>

<output>
After completion, create `.planning/phases/10-textual-core/10-05-SUMMARY.md`
</output>
