---
phase: 01-keycycle-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - hfs/agno/__init__.py
  - hfs/agno/providers.py
  - hfs/agno/models.py
autonomous: true

must_haves:
  truths:
    - "ProviderManager initializes all four providers (Cerebras, Groq, Gemini, OpenRouter) from environment"
    - "get_model() returns a rotating Agno model for any configured provider"
    - "Wrapper shutdown is registered with atexit for clean cleanup"
    - "Environment validation logs key counts at startup"
  artifacts:
    - path: "hfs/agno/__init__.py"
      provides: "Module exports for ProviderManager and model factory"
      exports: ["ProviderManager", "get_model"]
    - path: "hfs/agno/providers.py"
      provides: "ProviderManager class with wrapper initialization"
      contains: "class ProviderManager"
      min_lines: 80
    - path: "hfs/agno/models.py"
      provides: "Model factory and convenience functions"
      contains: "def get_model"
      min_lines: 40
  key_links:
    - from: "hfs/agno/providers.py"
      to: "keycycle.MultiProviderWrapper"
      via: "from_env() initialization"
      pattern: "MultiProviderWrapper\\.from_env"
    - from: "hfs/agno/providers.py"
      to: "atexit"
      via: "shutdown registration"
      pattern: "atexit\\.register"
    - from: "hfs/agno/models.py"
      to: "hfs/agno/providers.py"
      via: "ProviderManager import"
      pattern: "from.*providers.*import.*ProviderManager"
---

<objective>
Create the Keycycle provider integration layer for HFS with multi-provider wrapper initialization and model factory.

Purpose: Establishes the foundation for HFS to obtain rotating Agno models from Keycycle with automatic key rotation and rate limiting.
Output: Working `hfs/agno/` module with ProviderManager and model factory ready for use by triads.
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-keycycle-foundation/01-RESEARCH.md

# Keycycle library is already installed in .venv
# Reference the research document for exact API patterns
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProviderManager class</name>
  <files>hfs/agno/__init__.py, hfs/agno/providers.py</files>
  <action>
Create the `hfs/agno/` directory and implement ProviderManager:

1. Create `hfs/agno/__init__.py`:
   - Export ProviderManager from providers
   - Export get_model from models (will be created in Task 2)

2. Create `hfs/agno/providers.py` with ProviderManager class:
   - Import from keycycle: MultiProviderWrapper, NoAvailableKeyError, RateLimitError, InvalidKeyError
   - Import atexit, logging, os
   - Define PROVIDER_CONFIGS constant:
     ```python
     PROVIDER_CONFIGS = [
         ("cerebras", "llama-3.3-70b"),
         ("groq", "llama-3.3-70b-versatile"),
         ("gemini", "gemini-2.5-flash"),
         ("openrouter", "meta-llama/llama-3.3-70b-instruct:free"),
     ]
     ```
   - Class ProviderManager:
     - `__init__(self)`: Initialize empty wrappers dict, call _init_providers(), register shutdown with atexit
     - `_init_providers(self)`: Loop through PROVIDER_CONFIGS, create MultiProviderWrapper.from_env() for each
       - Log success with key count: `logger.info(f"Initialized {provider} with {len(wrapper.manager.keys)} keys")`
       - Catch exceptions, log error, continue to next provider (don't crash on single provider failure)
     - `_validate_environment(self)`: Check NUM_CEREBRAS, NUM_GROQ, NUM_GEMINI, NUM_OPENROUTER env vars exist
       - Log warning if any missing: "Expected NUM_{PROVIDER} environment variable"
     - `get_model(self, provider: str, model_id: str | None = None, **kwargs)`:
       - Raise ValueError if provider not in self.wrappers
       - Call wrapper.get_model() with estimated_tokens=1000, wait=True, timeout=10.0, max_retries=5 as defaults
       - Allow kwargs to override defaults
       - Pass model_id if provided, else use wrapper's default
     - `shutdown(self)`: Loop through wrappers, call wrapper.manager.stop(), log each
     - `@property available_providers(self) -> list[str]`: Return list of initialized provider names

Call _validate_environment() at the START of __init__ before _init_providers().

Use type hints throughout. Add docstrings for class and public methods.
  </action>
  <verify>
```bash
cd C:\Users\jinwi\programming_files_NEW\agentive
python -c "from hfs.agno.providers import ProviderManager, PROVIDER_CONFIGS; print('ProviderManager imports OK'); print(f'Configs: {len(PROVIDER_CONFIGS)} providers')"
```
Should print "ProviderManager imports OK" and "Configs: 4 providers"
  </verify>
  <done>
ProviderManager class exists with __init__, _init_providers, _validate_environment, get_model, shutdown, and available_providers methods. Module imports without error.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create model factory</name>
  <files>hfs/agno/models.py</files>
  <action>
Create `hfs/agno/models.py` with convenience functions:

1. Import ProviderManager from .providers
2. Import NoAvailableKeyError from keycycle
3. Import logging

4. Module-level singleton pattern:
   ```python
   _provider_manager: ProviderManager | None = None

   def get_provider_manager() -> ProviderManager:
       """Get or create the global ProviderManager instance."""
       global _provider_manager
       if _provider_manager is None:
           _provider_manager = ProviderManager()
       return _provider_manager
   ```

5. Main function `get_model(provider: str, model_id: str | None = None, **kwargs)`:
   - Get provider manager via get_provider_manager()
   - Call manager.get_model(provider, model_id, **kwargs)
   - Return the model
   - Docstring explaining this is the main entry point for obtaining rotating Agno models

6. Convenience functions (thin wrappers around get_model):
   ```python
   def get_cerebras_model(model_id: str = "llama-3.3-70b", **kwargs):
       """Get a rotating Cerebras model."""
       return get_model("cerebras", model_id, **kwargs)

   def get_groq_model(model_id: str = "llama-3.3-70b-versatile", **kwargs):
       """Get a rotating Groq model."""
       return get_model("groq", model_id, **kwargs)

   def get_gemini_model(model_id: str = "gemini-2.5-flash", **kwargs):
       """Get a rotating Gemini model."""
       return get_model("gemini", model_id, **kwargs)

   def get_openrouter_model(model_id: str = "meta-llama/llama-3.3-70b-instruct:free", **kwargs):
       """Get a rotating OpenRouter model."""
       return get_model("openrouter", model_id, **kwargs)
   ```

7. Function to list available models per provider:
   ```python
   def list_available_providers() -> list[str]:
       """List providers that were successfully initialized."""
       return get_provider_manager().available_providers
   ```

8. Update `hfs/agno/__init__.py` to export:
   - ProviderManager
   - get_model, get_provider_manager
   - get_cerebras_model, get_groq_model, get_gemini_model, get_openrouter_model
   - list_available_providers

Use type hints. Add module docstring explaining this is the model factory for HFS Agno integration.
  </action>
  <verify>
```bash
cd C:\Users\jinwi\programming_files_NEW\agentive
python -c "from hfs.agno import get_model, get_cerebras_model, list_available_providers; print('Model factory imports OK')"
```
Should print "Model factory imports OK"
  </verify>
  <done>
Model factory exists with get_model, provider-specific helpers, and list_available_providers. All functions exported from hfs.agno package.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add environment validation with startup diagnostics</name>
  <files>hfs/agno/providers.py</files>
  <action>
Enhance the ProviderManager with detailed startup diagnostics:

1. Update _validate_environment to be more comprehensive:
   ```python
   def _validate_environment(self) -> dict[str, dict]:
       """Validate environment variables and return status report."""
       expected = {
           "cerebras": {"env_var": "NUM_CEREBRAS", "expected": 51},
           "groq": {"env_var": "NUM_GROQ", "expected": 16},
           "gemini": {"env_var": "NUM_GEMINI", "expected": 110},
           "openrouter": {"env_var": "NUM_OPENROUTER", "expected": 31},
       }

       status = {}
       for provider, info in expected.items():
           actual = os.environ.get(info["env_var"])
           if actual is None:
               logger.warning(f"Missing {info['env_var']} environment variable")
               status[provider] = {"configured": False, "keys": 0, "expected": info["expected"]}
           else:
               try:
                   count = int(actual)
                   if count != info["expected"]:
                       logger.warning(f"{info['env_var']}={count}, expected {info['expected']}")
                   status[provider] = {"configured": True, "keys": count, "expected": info["expected"]}
               except ValueError:
                   logger.error(f"{info['env_var']} is not a valid integer: {actual}")
                   status[provider] = {"configured": False, "keys": 0, "expected": info["expected"]}

       # Check TIDB_DB_URL
       if not os.environ.get("TIDB_DB_URL"):
           logger.warning("TIDB_DB_URL not set - usage statistics will not be persisted")

       return status
   ```

2. Store the status report as self._env_status in __init__

3. Add property to expose environment status:
   ```python
   @property
   def environment_status(self) -> dict[str, dict]:
       """Return environment validation status for all providers."""
       return self._env_status
   ```

4. Add method to check if provider is fully configured:
   ```python
   def is_provider_healthy(self, provider: str) -> bool:
       """Check if a provider is fully configured and initialized."""
       return (
           provider in self._env_status
           and self._env_status[provider]["configured"]
           and provider in self.wrappers
       )
   ```

5. Enhance _init_providers to log a summary after initialization:
   ```python
   # At end of _init_providers:
   healthy = [p for p in PROVIDER_CONFIGS if self.is_provider_healthy(p[0])]
   logger.info(f"Provider initialization complete: {len(healthy)}/{len(PROVIDER_CONFIGS)} providers healthy")
   ```
  </action>
  <verify>
```bash
cd C:\Users\jinwi\programming_files_NEW\agentive
python -c "
from hfs.agno.providers import ProviderManager
# This will log warnings about missing env vars (expected in test)
import logging
logging.basicConfig(level=logging.WARNING)
pm = ProviderManager()
print(f'Environment status keys: {list(pm.environment_status.keys())}')
print(f'is_provider_healthy method exists: {hasattr(pm, \"is_provider_healthy\")}')
"
```
Should show environment status for all 4 providers and confirm is_provider_healthy exists.
  </verify>
  <done>
ProviderManager has comprehensive environment validation, environment_status property, and is_provider_healthy method. Startup logs show provider health summary.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Import test:
```bash
python -c "from hfs.agno import ProviderManager, get_model, list_available_providers; print('All imports OK')"
```

2. Module structure check:
```bash
ls hfs/agno/
# Should show: __init__.py, providers.py, models.py
```

3. Syntax validation:
```bash
python -m py_compile hfs/agno/providers.py hfs/agno/models.py hfs/agno/__init__.py
echo "Syntax OK"
```
</verification>

<success_criteria>
- [ ] `hfs/agno/` directory exists with __init__.py, providers.py, models.py
- [ ] ProviderManager initializes wrappers for all 4 providers (with graceful failure handling)
- [ ] get_model() function returns rotating Agno models
- [ ] Environment validation logs warnings for missing env vars
- [ ] atexit shutdown registered for clean wrapper cleanup
- [ ] All files pass syntax check and import without error
</success_criteria>

<output>
After completion, create `.planning/phases/01-keycycle-foundation/01-01-SUMMARY.md`
</output>
