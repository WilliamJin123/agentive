---
phase: 04-shared-state
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - hfs/agno/state/__init__.py
  - hfs/agno/state/schemas.py
  - hfs/agno/state/parser.py
  - hfs/agno/state/manager.py
autonomous: true

must_haves:
  truths:
    - "SharedStateManager can read markdown state file without locking"
    - "SharedStateManager can write state with FIFO-queued locking"
    - "Parser extracts WorkItem from markdown lines with IP markers"
    - "Write timeout returns structured error, not exception"
  artifacts:
    - path: "hfs/agno/state/schemas.py"
      provides: "WorkItem, input/output schemas for state tools"
      exports: ["WorkItem", "WorkItemStatus", "GetWorkItemsInput", "GetWorkItemsOutput", "UpdateWorkItemInput", "UpdateWorkItemOutput"]
    - path: "hfs/agno/state/parser.py"
      provides: "Markdown parsing utilities for IP markers"
      exports: ["parse_work_item", "add_ip_marker", "remove_ip_marker", "WORK_ITEM_PATTERN"]
    - path: "hfs/agno/state/manager.py"
      provides: "SharedStateManager with async I/O and write serialization"
      exports: ["SharedStateManager"]
  key_links:
    - from: "hfs/agno/state/manager.py"
      to: "hfs/agno/state/parser.py"
      via: "parse_work_item import for state parsing"
      pattern: "from .parser import"
    - from: "hfs/agno/state/manager.py"
      to: "asyncio.Lock"
      via: "_write_lock for FIFO-fair write serialization"
      pattern: "_write_lock = asyncio.Lock"
---

<objective>
Create the core shared state infrastructure: Pydantic schemas, markdown parser, and SharedStateManager class with async I/O and FIFO-queued write locking.

Purpose: Enable multi-agent coordination via markdown state files with proper concurrency control
Output: Manager class that can read/write state files, parser for IP markers, and typed schemas
</objective>

<execution_context>
@C:\Users\jinwi\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\jinwi\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-shared-state/04-CONTEXT.md
@.planning/phases/04-shared-state/04-RESEARCH.md
@hfs/agno/tools/schemas.py
@hfs/agno/tools/toolkit.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Pydantic schemas for shared state</name>
  <files>hfs/agno/state/__init__.py, hfs/agno/state/schemas.py</files>
  <action>
Create the state module with Pydantic schemas following Phase 2 patterns:

1. Create `hfs/agno/state/__init__.py` with placeholder exports (will be updated in later tasks)

2. Create `hfs/agno/state/schemas.py` with:

**WorkItemStatus enum:**
- AVAILABLE = "available"
- IN_PROGRESS = "in_progress"
- COMPLETED = "completed"

**WorkItem model:**
- description: str (the task text)
- status: WorkItemStatus (computed from is_complete and claimed_by)
- claimed_by: Optional[str] (agent ID if claimed)
- line_number: int (position in state file)
- is_complete: bool (checkbox checked)
- raw_line: str (original markdown)
- Property `status` that returns available/in_progress/completed based on is_complete and claimed_by

**GetWorkItemsInput:**
- status: Optional[Literal["available", "in_progress", "completed"]] (filter)

**GetWorkItemsOutput:**
- success: bool
- message: str
- items: List[WorkItem]
- counts: Dict[str, int] (count by status)

**UpdateWorkItemInput:**
- description: str (work item to match)
- action: Literal["claim", "complete", "release", "add"]
- new_description: Optional[str] (for "add" action only)
- Model validator: require new_description when action is "add"

**UpdateWorkItemOutput:**
- success: bool
- message: str
- description: str
- status: Optional[str]
- claimed_by: Optional[str]
- error_reason: Optional[str]
- hint: Optional[str]

**AgentMemorySection enum:**
- SCRATCHPAD = "scratchpad"
- SUBTASKS = "subtasks"
- NOTES = "notes"

**UpdateAgentMemoryInput:**
- section: AgentMemorySection
- content: str
- append: bool = False

**UpdateAgentMemoryOutput:**
- success: bool
- message: str
- section: str
- preview: str (first 200 chars of updated section)

Follow the Phase 2 schema patterns: Field validators, descriptive docstrings, model validators for cross-field validation.
  </action>
  <verify>python -c "from hfs.agno.state.schemas import WorkItem, WorkItemStatus, GetWorkItemsInput, UpdateWorkItemInput; print('Schemas import OK')"</verify>
  <done>All schema classes defined with proper validation; imports work without errors</done>
</task>

<task type="auto">
  <name>Task 2: Create markdown parser utilities</name>
  <files>hfs/agno/state/parser.py</files>
  <action>
Create `hfs/agno/state/parser.py` with markdown parsing utilities for work items and IP markers:

**WORK_ITEM_PATTERN regex:**
Matches: `- [ ] Task description [IP:agent-id]`
- Captures: checkbox state (space or x), task text, optional IP marker
- Pattern: `r'^(\s*-\s*\[)([ xX])(\]\s*)(.+?)(\s*\[IP:([^\]]+)\])?\s*$'`

**parse_work_item(line: str, line_num: int = 0) -> Optional[WorkItem]:**
- Return None if line doesn't match work item pattern
- Extract checkbox state, description, claimed_by from regex groups
- Create WorkItem with computed fields

**add_ip_marker(line: str, agent_id: str) -> str:**
- Remove existing IP marker if present (avoid duplicates)
- Append `[IP:agent_id]` to end of line
- Return modified line

**remove_ip_marker(line: str) -> str:**
- Remove `[IP:...]` marker from line
- Return cleaned line

**mark_complete(line: str) -> str:**
- Change `- [ ]` to `- [x]`
- Remove any IP marker (completed items don't need claims)
- Return modified line

**Section parsing functions:**
- get_section_range(content: str, section_name: str) -> Tuple[int, int]: Find start/end line numbers for a markdown section (## heading)
- extract_section(content: str, section_name: str) -> str: Get content of a named section

All functions should be pure (no side effects) and handle edge cases (empty strings, malformed lines).
  </action>
  <verify>python -c "from hfs.agno.state.parser import parse_work_item, add_ip_marker, remove_ip_marker; item = parse_work_item('- [ ] Test task'); print(f'Parsed: {item}')"</verify>
  <done>Parser functions extract IP markers correctly; add/remove marker functions modify lines as expected</done>
</task>

<task type="auto">
  <name>Task 3: Create SharedStateManager with async I/O and locking</name>
  <files>hfs/agno/state/manager.py, hfs/agno/state/__init__.py</files>
  <action>
Create `hfs/agno/state/manager.py` with the SharedStateManager class:

**Class: SharedStateManager**
```python
class SharedStateManager:
    """Manages shared state file with async I/O and write serialization.

    Reads are non-blocking (per CONTEXT.md).
    Writes queue up and execute in FIFO order via asyncio.Lock.
    """

    DEFAULT_TIMEOUT = 30.0  # seconds
    DEFAULT_STATE_PATH = Path(".hfs/state.md")

    def __init__(
        self,
        state_path: Path = DEFAULT_STATE_PATH,
        timeout_seconds: float = DEFAULT_TIMEOUT,
    ):
        self._state_path = Path(state_path)
        self._timeout = timeout_seconds
        self._write_lock = asyncio.Lock()
```

**Methods:**

`async def read_state(self) -> str:`
- Non-blocking read (no lock)
- Return initial template if file doesn't exist
- Use aiofiles.open for async I/O

`async def write_state(self, content: str) -> Dict[str, Any]:`
- Acquire lock with timeout via asyncio.wait_for
- Return {"success": False, "reason": "lock_timeout", "hint": "..."} on timeout
- Create parent directories if needed
- Atomic write: write to temp file, then rename
- Return {"success": True} on success
- Return {"success": False, "reason": "write_error", "error": str(e)} on error
- Always release lock in finally block

`async def get_work_items(self, status: Optional[str] = None) -> List[WorkItem]:`
- Read state, parse all work items
- Filter by status if provided
- Return list of WorkItem objects

`async def claim_item(self, description: str, agent_id: str) -> Dict[str, Any]:`
- Read-modify-write with lock
- Find item by description
- Return error if not found or not available
- Add IP marker and write back
- Return success with updated item info

`async def complete_item(self, description: str, agent_id: str) -> Dict[str, Any]:`
- Similar to claim_item
- Verify caller owns the item (has claim)
- Mark checkbox as complete, remove IP marker
- Move item to Completed section

`async def release_item(self, description: str, agent_id: str) -> Dict[str, Any]:`
- Remove IP marker from item caller has claimed
- Return error if not claimed by this agent

`async def add_item(self, description: str) -> Dict[str, Any]:`
- Add new work item to Available section
- Return success with item details

`def _get_initial_template(self) -> str:`
- Return initial state file template with sections:
  - # Shared State
  - ## Available Work Items
  - ## In Progress
  - ## Completed
  - ## Agent Registry (table)

**Per-agent memory methods:**

`async def read_agent_memory(self, agent_id: str) -> str:`
- Read from .hfs/agents/{agent_id}.md
- Return template if doesn't exist

`async def write_agent_memory(self, agent_id: str, section: str, content: str, append: bool = False) -> Dict[str, Any]:`
- Update specific section of agent memory file
- Create file with template if doesn't exist

**Update `hfs/agno/state/__init__.py`:**
- Export SharedStateManager and all schemas
- Export parser functions for external use
  </action>
  <verify>python -c "from hfs.agno.state import SharedStateManager; m = SharedStateManager(); print(f'Manager created: {m._state_path}')"</verify>
  <done>SharedStateManager initializes correctly; read_state and write_state methods exist; exports work from package __init__.py</done>
</task>

</tasks>

<verification>
Run all verification commands:
```bash
python -c "from hfs.agno.state import SharedStateManager, WorkItem, WorkItemStatus, parse_work_item, add_ip_marker"
python -c "from hfs.agno.state.schemas import GetWorkItemsInput, UpdateWorkItemInput, UpdateWorkItemOutput"
python -c "from hfs.agno.state.manager import SharedStateManager; print('Manager OK')"
python -c "from hfs.agno.state.parser import WORK_ITEM_PATTERN; print('Parser OK')"
```

Verify async methods exist:
```bash
python -c "import asyncio; from hfs.agno.state import SharedStateManager; m = SharedStateManager(); assert hasattr(m, 'read_state'); assert hasattr(m, 'write_state'); assert hasattr(m, 'get_work_items'); print('Async methods OK')"
```
</verification>

<success_criteria>
- SharedStateManager class exists with read_state, write_state, get_work_items, claim_item, complete_item, release_item, add_item methods
- All methods are async (use aiofiles, asyncio.Lock)
- Write operations return dict with success flag (not exceptions)
- Parser utilities extract and modify IP markers correctly
- Pydantic schemas validate inputs with proper error messages
- Package exports work from hfs/agno/state/__init__.py
</success_criteria>

<output>
After completion, create `.planning/phases/04-shared-state/04-01-SUMMARY.md`
</output>
