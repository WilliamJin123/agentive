---
phase: 04-shared-state
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - hfs/agno/state/toolkit.py
  - hfs/agno/state/__init__.py
  - hfs/agno/__init__.py
  - hfs/tests/test_shared_state.py
autonomous: true

must_haves:
  truths:
    - "get_work_items returns filtered work items as JSON"
    - "update_work_item can claim, complete, release, and add items"
    - "get_agent_memory returns agent's local memory file"
    - "update_agent_memory writes to agent's memory section"
    - "Unit tests verify all manager, parser, and toolkit methods"
  artifacts:
    - path: "hfs/agno/state/toolkit.py"
      provides: "SharedStateToolkit with 4 Agno tools"
      exports: ["SharedStateToolkit"]
    - path: "hfs/tests/test_shared_state.py"
      provides: "Unit tests for shared state module"
      min_lines: 150
  key_links:
    - from: "hfs/agno/state/toolkit.py"
      to: "hfs/agno/state/manager.py"
      via: "SharedStateManager dependency injection"
      pattern: "self._manager"
    - from: "hfs/agno/state/toolkit.py"
      to: "agno.tools.toolkit.Toolkit"
      via: "Toolkit base class inheritance"
      pattern: "class SharedStateToolkit\\(Toolkit\\)"
---

<objective>
Create SharedStateToolkit with 4 Agno tools and comprehensive unit tests for the shared state module.

Purpose: Provide agents with tools to coordinate work via shared state files
Output: Toolkit class ready for agent use; tests validating all functionality
</objective>

<execution_context>
@C:\Users\jinwi\.claude\get-shit-done\workflows\execute-plan.md
@C:\Users\jinwi\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-shared-state/04-CONTEXT.md
@.planning/phases/04-shared-state/04-RESEARCH.md
@.planning/phases/04-shared-state/04-01-SUMMARY.md
@hfs/agno/tools/toolkit.py
@hfs/agno/tools/schemas.py
@hfs/agno/tools/errors.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SharedStateToolkit with 4 Agno tools</name>
  <files>hfs/agno/state/toolkit.py, hfs/agno/state/__init__.py, hfs/agno/__init__.py</files>
  <action>
Create `hfs/agno/state/toolkit.py` following the HFSToolkit pattern from Phase 2:

**Class: SharedStateToolkit(Toolkit)**
```python
class SharedStateToolkit(Toolkit):
    """Tools for multi-agent coordination via shared state.

    Provides:
    - get_work_items(): Query available/claimed/completed items
    - update_work_item(): Claim, complete, or release work items
    - get_agent_memory(): Read agent's local memory file
    - update_agent_memory(): Write to agent's local memory file
    """

    def __init__(
        self,
        manager: SharedStateManager,
        agent_id: str,
        **kwargs,
    ):
        self._manager = manager
        self._agent_id = agent_id

        tools: List[Callable] = [
            self.get_work_items,
            self.update_work_item,
            self.get_agent_memory,
            self.update_agent_memory,
        ]

        super().__init__(name="shared_state", tools=tools, **kwargs)
```

**Tool 1: get_work_items(status: Optional[str] = None) -> str**

Docstring:
```
Query work items from shared state.

WHEN TO USE: Before starting work to see what's available,
or to check what you've claimed.

FILTERS:
- status="available": Items not claimed by any agent
- status="in_progress": Items currently claimed (by you or others)
- status="completed": Finished items
- status=None: Return all items

EXAMPLE:
>>> get_work_items(status="available")

Args:
    status: Filter by status. One of: "available", "in_progress", "completed", or None for all.

Returns:
    JSON with list of work items matching filter, grouped by status.
```

Implementation:
- Run asyncio event loop to call manager.get_work_items()
- Build GetWorkItemsOutput with items and counts
- Return output.model_dump_json()

**Tool 2: update_work_item(description: str, action: str, new_description: Optional[str] = None) -> str**

Docstring:
```
Update a work item's status.

WHEN TO USE: To claim work before starting, mark complete when done,
or release if you can't finish.

ACTIONS:
- "claim": Mark item as in-progress with your agent ID
- "complete": Mark item as done (checkbox checked)
- "release": Remove your claim (if you can't finish)
- "add": Add a new work item to the available list

IMPORTANT CONSTRAINTS:
- Can only claim items with status="available"
- Can only complete items you have claimed
- Can only release items you have claimed
- Description must match an existing item (for claim/complete/release)

EXAMPLE:
>>> update_work_item(description="Build auth module", action="claim")
>>> update_work_item(description="Build auth module", action="complete")

Args:
    description: The work item description to match (or new description for "add")
    action: One of "claim", "complete", "release", "add"
    new_description: For "add" action only - the new work item text

Returns:
    JSON with success status and updated item details.
```

Implementation:
- Validate input with UpdateWorkItemInput schema
- Route to appropriate manager method based on action
- Return UpdateWorkItemOutput as JSON

**Tool 3: get_agent_memory() -> str**

Docstring:
```
Read your local memory file.

WHEN TO USE: At the start of a work session to recall context,
or when you need to reference your previous notes.

Returns:
    JSON with your memory file contents (scratchpad, subtasks, notes).
    Returns empty template if no memory file exists yet.
```

Implementation:
- Call manager.read_agent_memory(self._agent_id)
- Return JSON with memory content

**Tool 4: update_agent_memory(section: str, content: str, append: bool = False) -> str**

Docstring:
```
Update your local memory file.

WHEN TO USE: To save context for later, track subtasks,
or record notes and learnings.

SECTIONS:
- "scratchpad": Working notes and current approach
- "subtasks": Your personal task breakdown
- "notes": Observations and learnings

EXAMPLE:
>>> update_agent_memory(section="scratchpad", content="Implementing OAuth2 flow...")
>>> update_agent_memory(section="subtasks", content="- [ ] Add token refresh", append=True)

Args:
    section: Which section to update ("scratchpad", "subtasks", "notes")
    content: The content to write
    append: If True, append to existing content; if False, replace

Returns:
    JSON with success status and updated section preview.
```

Implementation:
- Validate input with UpdateAgentMemoryInput schema
- Call manager.write_agent_memory(self._agent_id, section, content, append)
- Return UpdateAgentMemoryOutput as JSON

**Helper for sync wrapper:**
Use `asyncio.get_event_loop().run_until_complete()` or create new event loop if none exists, to call async manager methods from sync tool functions. Agno tools are sync, but manager uses async I/O.

**Update exports:**

Update `hfs/agno/state/__init__.py`:
- Add SharedStateToolkit to exports

Update `hfs/agno/__init__.py`:
- Add state module exports (SharedStateManager, SharedStateToolkit, WorkItem)
  </action>
  <verify>python -c "from hfs.agno.state import SharedStateToolkit, SharedStateManager; m = SharedStateManager(); t = SharedStateToolkit(m, 'test-agent'); print(f'Toolkit tools: {[f.__name__ for f in t.tools]}')"</verify>
  <done>SharedStateToolkit has 4 tools; all tools have proper docstrings; exports work from hfs.agno.state and hfs.agno</done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for shared state module</name>
  <files>hfs/tests/test_shared_state.py</files>
  <action>
Create `hfs/tests/test_shared_state.py` with comprehensive unit tests:

**Test Structure:**
```python
import pytest
import asyncio
import tempfile
from pathlib import Path
from unittest.mock import AsyncMock, patch, MagicMock

from hfs.agno.state import (
    SharedStateManager,
    SharedStateToolkit,
    WorkItem,
    WorkItemStatus,
)
from hfs.agno.state.schemas import (
    GetWorkItemsInput,
    UpdateWorkItemInput,
    UpdateAgentMemoryInput,
)
from hfs.agno.state.parser import (
    parse_work_item,
    add_ip_marker,
    remove_ip_marker,
    mark_complete,
    WORK_ITEM_PATTERN,
)
```

**Parser Tests (6+ tests):**
- test_parse_work_item_available: `- [ ] Task` -> WorkItem(status=available)
- test_parse_work_item_with_ip_marker: `- [ ] Task [IP:agent-1]` -> WorkItem(claimed_by="agent-1")
- test_parse_work_item_completed: `- [x] Task` -> WorkItem(is_complete=True)
- test_parse_work_item_invalid: Returns None for non-matching lines
- test_add_ip_marker: Adds marker correctly
- test_add_ip_marker_replaces_existing: Replaces old marker
- test_remove_ip_marker: Removes marker
- test_mark_complete: Changes checkbox and removes marker

**Schema Tests (4+ tests):**
- test_work_item_status_available: No claim, not complete -> available
- test_work_item_status_in_progress: Has claim, not complete -> in_progress
- test_work_item_status_completed: is_complete=True -> completed
- test_update_work_item_input_requires_description_for_add: Validator test

**Manager Tests (8+ tests, use temp directory):**
- test_manager_read_state_creates_template: First read returns template
- test_manager_write_state_success: Write and read back
- test_manager_write_state_creates_directory: Creates .hfs/ if missing
- test_manager_get_work_items_all: Returns all items
- test_manager_get_work_items_filtered: Filters by status
- test_manager_claim_item_success: Claims available item
- test_manager_claim_item_already_claimed: Returns error
- test_manager_claim_item_not_found: Returns error
- test_manager_complete_item_success: Marks complete
- test_manager_release_item_success: Releases claim
- test_manager_add_item: Adds new work item

**Toolkit Tests (6+ tests):**
- test_toolkit_has_four_tools: Check tool count and names
- test_toolkit_get_work_items_returns_json: Output is valid JSON
- test_toolkit_update_work_item_claim: Claim action works
- test_toolkit_get_agent_memory_empty: Returns template
- test_toolkit_update_agent_memory: Writes section

**Use pytest fixtures:**
- @pytest.fixture for temp state directory
- @pytest.fixture for SharedStateManager with temp path
- @pytest.fixture for SharedStateToolkit

**Mark async tests with @pytest.mark.asyncio**

Ensure tests clean up temp files/directories.
  </action>
  <verify>cd C:/Users/jinwi/programming_files_NEW/agentive && python -m pytest hfs/tests/test_shared_state.py -v --tb=short 2>&1 | head -50</verify>
  <done>All tests pass; coverage includes parser, schemas, manager, and toolkit; no test uses real filesystem outside temp directory</done>
</task>

</tasks>

<verification>
Run all tests:
```bash
cd C:/Users/jinwi/programming_files_NEW/agentive
python -m pytest hfs/tests/test_shared_state.py -v
```

Verify toolkit integration:
```bash
python -c "
from hfs.agno.state import SharedStateToolkit, SharedStateManager
import json

m = SharedStateManager()
t = SharedStateToolkit(m, 'test-agent')

# Check tool count
assert len(t.tools) == 4, f'Expected 4 tools, got {len(t.tools)}'

# Check tool names
tool_names = [f.__name__ for f in t.tools]
assert 'get_work_items' in tool_names
assert 'update_work_item' in tool_names
assert 'get_agent_memory' in tool_names
assert 'update_agent_memory' in tool_names

print('Toolkit integration OK')
"
```

Verify exports:
```bash
python -c "from hfs.agno import SharedStateManager, SharedStateToolkit; print('Exports from hfs.agno OK')"
```
</verification>

<success_criteria>
- SharedStateToolkit extends Agno Toolkit with 4 tools
- Each tool has comprehensive docstring with WHEN TO USE, CONSTRAINTS, EXAMPLE sections
- Tools validate inputs with Pydantic schemas
- Tools return JSON strings (consistent with HFSToolkit pattern)
- Unit tests cover all parser, schema, manager, and toolkit functionality
- All tests pass
- Exports work from hfs.agno.state and hfs.agno packages
</success_criteria>

<output>
After completion, create `.planning/phases/04-shared-state/04-02-SUMMARY.md`
</output>
